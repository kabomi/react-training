<section id="t-router">
  <h1>Teil VII</h1>
  <h2>Client-seitiges Routing (Überblick)</h2>
  <a href="code/schritte/6-router/public/index.html" target="_blank">Ziel-Anwendung</a>
</section>

<section>
  <h2>React Router</h2>
  <ul>
    <li>Kein Bestandteil von React</li>
    <li>Sehr häufig verwendet (de-facto Standard)</li>
    <li>
      Aktuelle Version 5:
      <a href="https://reacttraining.com/react-router/" target="_blank">
        https://reacttraining.com/react-router/</a
      >
    </li>
  </ul>
</section>
<section>
  <h3>Das Router-Objekt</h3>
  <p class="fragment">
    Top-Level-Objekt, das einmalig (oben) in der Komponenten Hierarchie eingebunden werden muss
  </p>
  <p class="fragment">
    Mehrere Ausprägungen zum Arbeiten mit den URL und der Browser History:
  </p>
  <ul>
    <li class="fragment"><b>HashRouter</b>: codiert Pfad in angehängten Hash (#/greetings)</li>
    <li class="fragment"><b>BrowserRouter</b>: codiert Pfad direkt in URL (/greetings)</li>
  </ul>
  <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
import {HashRouter as Router} from "react-router-dom";

const app = &lt;Router>&lt;GreetingController/>&lt;/Router>;

ReactDOM.render(app, document.getElementById(...));
      </code></pre>
</section>

<section>
  <h3>Welche Komponente soll für einen Pfad gerendert werden</h3>
  <p class="fragment">Das <code>Route</code>-Objekt mappt Pfade auf Komponenten</p>
  <ul>
    <li class="fragment">
      Wird verwendet, wo Pfad-abhängig Komponenten ausgewählt werden sollen
      <ul>
        <li>vergleichbar mit intelligentem <code>if</code>/ <code>switch</code> statement</li>
        <li>
          <b>Kann überall in der Anwendung</b> verwendet werden (auf allen Hierarchie-Ebenenen)
        </li>
      </ul>
    </li>
    <li class="fragment">
      Mit <code>path</code> wird der Pfad übergeben, für den die Route matchen soll
    </li>
    <li class="fragment">Mit <code>component</code> wird die Komponente übergeben</li>
  </ul>
  <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
import {HashRouter as Router, Route} from "react-router-dom";

const app = &lt;Router>
&lt;Route path="/greet/:greetingId" component={GreetingDisplayController}/>
&lt;Route path="/" component={GreetingController}/>
&lt;/Router>;

ReactDOM.render(app, document.getElementById(...));
      </code></pre>
</section>
<section>
  <h3>Route #2: Das render-Property</h3>
  <ul>
    <li>
      Statt einer Komponente kann eine Funktion übergeben werden, die eine Komponente zurückliefert
    </li>
    <li>Ermöglicht es, zusätzliche Properties an die Komponente zu übergeben</li>
    <li>Kann unterschiedliche Komponenten zurückliefern (z.B. für Authorisierung)</li>
    <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
&lt;Route path="/"
render={() => {
  return loggedIn ? 
    &lt;GreetingMaster greetings={initialGreetings} />
  :
    &lt;LoginForm />
}}
/>
      </code></pre>
  </ul>
</section>

<section>
  <h3>Router Properties für Komponente</h3>
  <p>Der Router übergibt automatisch drei Properties an die gerenderte Komponente:</p>
  <ul>
    <li class="fragment">
      <code>match</code>: Enthält u.a. die Parameter aus dem Pfad ( <code>match.params.xyz</code>)
    </li>
    <li class="fragment">
      <code>history</code>: Zum Arbeiten mit der History (z.B. <code>push()</code> zum Navigieren)
    </li>
    <li class="fragment">
      <code>location</code>: Der aktuelle Pfad (z.B. <code>pathname</code>, <code>search</code>)
    </li>
  </ul>
  <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
const HelloComponent = ({match, history, location}) => (
&lt;div>
  &lt;h1>Hello, {match.params.name}&lt;/h1>
  &lt;small>The current path is: {location.pathname}&lt;/small>
  &lt;button onClick={() =&gt; history.push('/greetings')}>Show Greetings&lt;/button>
&lt;/div>
);

// ...
&lt;Route path="/greet/:name" component={HelloComponent}/>

      </code></pre>
  <ul>
    <li class="fragment">
      Die Properties werden auch an die <code>render</code>-Funktion einer <code>Route</code> als
      Parameter übergeben
    </li>
  </ul>
  <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
&lt;Route path="/somewhere" render={({match, history, location}) => . . . }/>
        
                </code></pre>
</section>

<section>
  <h3>Links</h3>
  <p>Mit <code>Link</code> und <code>NavLink</code> können Links erzeugt werden</p>
  <ul>
    <li>Mit <code>to</code> wird das Ziel angegeben</li>
    <li>Gerendert wird per default ein <code>a</code> Element</li>
    <li>URL wird entsprechend der History (Browser oder Hash) erzeugt</li>
    <li>
      Mit <code>activeClassName</code> und <code>activeStyle</code> auf <code>NavLink</code> können
      Styles übergeben werden, die angewendet werden, wenn der Link der aktiven Route entspricht
    </li>
  </ul>

  <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
import {Link, NavLink} from "react-router-dom";

&lt;Link to='/greetings'>Show all greetings&lt;/Link>

// Erzeugtes 'a' Element erhält 'highlight' CSS-Klasse, wenn die aktive Route
&lt;NavLink to='/greeting/me' activeClassName="highlight">Greet me&lt;/NavLink>

      </code></pre>
</section>

<section>
  <h3>Das history-Objekt</h3>
  <p class="fragment">
    Mit dem <code>history</code>-Objekt kann mit der Browser History interagiert werden
  </p>
  <p class="fragment">
    Es gibt verschiende Implementierungen (insb BrowserHistory und HashHistory sowie "memory
    history" für Testen)
  </p>
  <p class="fragment">
    Mit der History kann auf andere URLs gesprungen werden oder die Location abgefragt werden
  </p>
  <p class="fragment">Route-Komponenten erhalten die history automatisch per Property</p>
  <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
function GreetingController({history}) {
// gehe zu neuer URL
history.push("/..."); 

// gehe zu neuer URL, lösche aber aktuelle aus History im Browser
history.replace("/...") 

// aktuelle URL
const currentPath = history.location.pathname; 
}
      </code></pre>
</section>

<section>
  <h3>Zugriff auf die history außerhalb von "Route Components"</h3>
  <ul>
    <li class="fragment">
      Komponenten, die von <code>Route</code> gerendert werden, erhalten automatisch Zugriff auf
      <code>history</code> etc
    </li>
    <li class="fragment">Für alle anderen Komponenten, brauchen wir eine andere Lösung</li>
    <li class="fragment">
      <code>withRouter</code> HOC "erweitert" Komponenten und Router Properties
    </li>
  </ul>
  <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
import {withRouter} from "react-router-dom";

function GreetLink(props) {
const greeting = this.props.greeting; // übergeben vom ursprünglichen Aufrufer
const history = this.props.history; // übergeben von withRouter
return &lt;div>
  &lt;button onClick={() =&gt; history.push(`/${greeting.id}`)}>Show Greeting&lt;/button>
&lt;/div>;
}

// 
export default withRouter(GreetingLink);
                </code></pre>
</section>
<section>
  <h3>withRouter zur Laufzeit</h3>
  <img src="slides/images/screenshot-withRouter.png" />
</section>

<section>
  <h3>Hintergrund</h3>
  <h2>Higher-Order Components (HOC)</h2>
  <p>https://reactjs.org/docs/higher-order-components.html</p>
  <p>
    Eine Higher-Order Komponente ist eine Funktion, die
    <b>eine Komponente entgegennimmt und eine neue Komponente zurückliefert</b>
  </p>
  <p class="fragment">
    Die Higher-Order-Kommponente ist für das <b>rendern</b> der ursprünglichen Komonente
    verantwortlich
  </p>
  <ul class="fragment">
    <li>Sie kann das Rendern bei Bedarf auch unterdrücken oder verzögern</li>
    <li>Sie hat Zugriff auf alle ursprünglichen Properties</li>
    <li>
      Sie kann der Ziel-Komponente zusätzliche Properties übergeben oder welche entfernen
    </li>
  </ul>
</section>
<section>
  <h3>Beispiel: Higher-Order Components (HOC)</h3>
  <p>
    Ziel:
    <em
      >Eine HOC, die ein Greeting lädt das geladene Greeting an die ursprüngliche Komponente
      weitergibt</em
    >
  </p>
  <div style="font-size:85%">
    <p>Vorteile:</p>
    <ul>
      <li>
        "Komplexe" Logik zum Laden der Daten, Fehlerbehandlung etc, liegt zentral in der HOC
      </li>
      <li>Die gewrappte Komponente muss sich nicht um das (technische) Laden kümmern</li>
      <li>
        Die gewrappte Komponente benötigt keinen Lifecycle, sie wird nur dargestellt, wenn ein
        Greeting vorhanden ist
      </li>
    </ul>
  </div>
  <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>

// GreetingDisplayController.js          
// GreetingDisplayController (stellt einen Gruß dar):
function GreetingDisplayController({greeting}) {
return &lt;h1>&lt;{greeting.name}, {greeting.greeting}&lt;/h1>;
}

// umschliessen mit der HOC
export default withGreeting(GreetingDisplayContainer);
</code></pre>
  <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
// Verwender
import GreetingDisplayController from "...";
// dass es sich um eine HOC handelt, ist für den Verwender transparent:
&lt;GreetingDisplayController greetingId={3} />
                                </code></pre>
</section>

<section>
  <h2>Der Router mit TypeScript</h2>
</section>

<section>
  <h3>RouteComponentProps</h3>
  <p>Der Router übergibt Properties an eine Route-Komponente</p>
  <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
// GreetingController erhält history etc als Property          
&lt;Route component={GreetingController} />
                                                  </code></pre>
  <p class="fragment">
    Die Route-Properties sind im Interface <code>RouteComponentProps</code> definiert
  </p>
  <p class="fragment">Die Komponente kann für ihre Properties das Interface erweitern:</p>
  <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
import { RouteComponentProps } from "react-router";
type GreetingControllerProps = RouteComponentProps&lt;void&gt; &amp; { 
// ggf. eigene Properties des GreetingControllers
}
function GreetingController(props:GreetingControllerProps) {
  const history = this.props.history; // ok, kein Compile-Fehler
}
</code></pre>
</section>
<section>
  <h3>RouteComponentProps #2</h3>
  <p>Der Router übergibt die Parameter aus der URL an die Route-Komponente</p>
  <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
// GreetingController erhält "greetingId" als Property
&lt;Route path="/greeting/:greetingId" component={GreetingController} />
                                                    </code></pre>
  <p class="fragment">
    RouteComponentProps ist mit den erwarteten Parametern aus der URL generifiziert
  </p>
  <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
import { RouteComponentProps } from "react-router";

// Die im Path definierten Parameter
type GreetingControllerParams = { greetingId: string };

// Als Type-Argument werden die Parameter angegeben
type GreetingControllerProps = 
RouteComponentProps&lt;GreetingControllerParams&gt; {   }

function GreetingController(props:GreetingControllerProps) {
  const params = this.props.match;

  const greetingId = params.greetingId; // ok, kein Compile-Fehler
  const userId = params.userId; // Fehler: userId nicht bekannt
  // ...
}
</code></pre>
</section>

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />

    <title>React and GraphQL Training</title>

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui"
    />
    <link rel="stylesheet" href="slides/styles.css" />
    <script src="slides/export.js"></script>
  </head>

  <body>
    <div class="reveal">
      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section data-state="title">
          <h2 class="title" style="font-size:7rem">
            <b>React &amp; GraphQL</b>
          </h2>

          <h4>
            <span class="transparent-bg">
              <a href="http://nilshartmann.net" target="_blank">Nils Hartmann</a> |
              <a href="http://twitter.com/nilshartmann" target="_blank">@nilshartmann</a>
            </span>
          </h4>

          <p style="margin-top:4rem"></p>
          <div>
            <h3><span class="transparent-bg">Preparation</span></h3>
            <p>
              <span class="transparent-bg"
                >git clone https://github.com/nilshartmann/react-training</span
              >
            </p>
            <p><span class="transparent-bg">cd react-training/blog-example/workspace</span></p>
            <p><span class="transparent-bg">npm install</span></p>
          </div>

          <p>
            <span class="transparent-bg">Slides: react-training/2020_react_and_graphql.html</span>
          </p>
        </section>
        <section>
          <h2>Nils Hartmann</h2>
          <p>
            <a href="https://nilshartmann.net" target="_blank">https://nilshartmann.net</a> /
            <a href="http://twitter.com/nilshartmann" target="_blank">@nilshartmann</a>
          </p>
          <p><em>Freelance software developer, trainer and coach from Hamburg </em></p>

          <div style="display:flex;justify-content:center">
            <div>
              <p>Java</p>
              <p>JavaScript, TypeScript</p>
              <p>React</p>
              <p>Single-Page-Applications</p>
              <p>GraphQL</p>
            </div>
          </div>
        </section>
        <section data-markdown>
          <textarea data-template>
                <h3><a href="https://reactbuch.de">https://reactbuch.de</a>                </h3>
              <a href="https://reactbuch.de"><img src='slides/images/react-buch-v2.png' style="max-height: 650px;">    </a>
              <p>ðŸŽ… 2., Ã¼berarbeitete und erweiterte Auflage, Dezember 2019 ðŸ¤¶</p>
            </textarea
          >
        </section>
        <section>
          <h2>Agenda</h2>
          <div>
            <ul style="font-size: 85%">
              <li class="todo">
                <a href="#/example-app">Das Beispiel</a> <br />Die Beispiel-Anwendung, der
                -Workspace und mÃ¶gliche Erweiterungen
              </li>
              <li>
                <a href="#/reactgrundlagen">React Grundlagen</a>
                <br />Komponenten, JSX, State und Properties
              </li>
              <li>
                <a href="#/server">Arbeiten mit einem Server (REST)</a>
                <br />useEffect, fetch
              </li>

              <li>
                <a href="#/t-router">Client-seitiges Routing</a>
                <br />React Router
              </li>
            </ul>
          </div>
        </section>

        <section id="example-app">
          <h1>Example Application</h1>
          <h2>and training workspace</h2>
        </section>

        <section>
          <h3>Example Application</h3>
          <a target="_blank" href="http://localhost:3000">
            <img src="blog-example/blog-example.png" style="height:650px" />
          </a>
        </section>

        <section>
          <h3 class="todo">Weiter hinten! Preparation</h3>
          <p>
            git clone https://github.com/nilshartmann/react-training
          </p>
          <p>
            cd react-training/blog-example/workspace
          </p>

          <p>
            npm install
          </p>

          <p></p>

          <p>
            npm start
          </p>

          <p></p>

          <p>Open in your browser: http://localhost:3000</p>

          <p>
            Slides: https://nils.buzz/techlab
          </p>
        </section>

        <section>
          <h3>Der Beispiel-Workspace</h3>
          <p>Im Verzeichnis <b>blog-example/workspace</b> ist schon alles vorbereitet</p>
          <p>
            Du kannst dort mit <b>npm install</b> und <b>npm start</b> die (leere) Anwendung starten
          </p>
          <p>
            In der Datei App.js kannst Du deine Anwendung implementieren <br />Dazu bitte in
            index.js die App-Komponente importieren (siehe Kommentare dort)
          </p>
          <p>
            Wenn Du Ã„nderungen machst, wird die Anwendung automatisch gebaut und im Browser
            aktualisiert
          </p>
        </section>

        <section>
          <h3>Tool-Chain starten</h3>

          <ol style="font-size: 85%">
            <li>
              <code>cd code/blog-example/workspace</code>
            </li>

            <li>
              <code>npm start</code>
            </li>

            <li>
              Ã–ffne <a href="http://localhost:3000" target="_blank">http://localhost:3000</a> im
              Browser
            </li>

            <li>Wenn auf der Seite 'Hello, World' steht, ist alles gut</li>
          </ol>

          <img style="height:400px" src="slides/images/screenshot-npm-start-cra.png" />
        </section>

        <section data-state="js-exkurs">
          <h2>React Devtools</h2>
          <em>React Developer Tools for Chrome and Firefox</em>
          <p>Inspect your React Application at Runtime</p>

          <ul>
            <li>
              <a
                href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=en"
                target="_blank"
                >Chrome</a
              >
            </li>
            <li>
              <a
                href="https://addons.mozilla.org/en-US/firefox/addon/react-devtools/"
                target="_blank"
                >Firefox</a
              >
            </li>
          </ul>

          <p><img src="slides/images/screenshot-react-dev-tools.png" /></p>
        </section>

        <section data-state="js-exkurs">
          <h3>create-react-app</h3>
          <a
            href="https://github.com/facebook/create-react-app/blob/master/packages/react-scripts/template/README.md#table-of-contents"
            target="_blank"
            >User Guide</a
          >
          <p>Can be used to create new React projects</p>
          <p>
            Contains complete configuration of all needed tools like Webpack, Babel, TypeScript, ...
          </p>
          <p>Example: npx create-react-app NAME_OF_YOUR_PROJECT --template typescript</p>
        </section>

        <!-- <section>
          <h2>Ãœbung 1: React Hello-World</h2>
          <h3>
            <em>Mach dich mit den Werkzeugen vertraut und schreib deine erste React-Komponente</em>
          </h3>
        </section>
        <section>
          <h3>Das Beispiel-Projekt</h3>
          <p>Workspace</p>
          <ul class="x-list">
            <li style="margin-bottom:40px">
              <code>2019_react_wdc_hh.html</code> Slides im Root-Verzeichnis
            </li>
            <li style="margin-bottom:40px">
              <code>code/<b>workspace</b></code
              >: Verzeichnis fÃ¼r Eure Ãœbungen<br />ðŸ‘‰&nbsp;Empfehlung: dieses Verzeichnis in VS
              Code/IDE Ã¶ffnen
            </li>
            <li>
              <code>code/<b>material</b></code
              >: Code als Ausgangspunkt fÃ¼r Ãœbungen
            </li>
            <li>
              <code>code/<b>schritte</b></code
              >: Fertige StÃ¤nde nach den einzelnen Teilen
            </li>
          </ul>
        </section> -->

        <section id="reactgrundlagen">
          <h1>React Basics</h1>
        </section>

        <section>
          <h2>React Documentation</h2>
          <p>
            <a href="https://reactjs.org/docs/hello-world.html">
              https://reactjs.org/docs/hello-world.html
            </a>
          </p>
        </section>

        <section>
          <h3>React Components</h3>
          <img src="slides/images/komponente.png" style="height:400px" />
          <ul>
            <li class="fragment">contain <b>State, Logic und UI</b></li>
            <li class="fragment">
              <b>no template language</b>
            </li>
            <li class="fragment">written in a <b>declarativede</b> way</li>
            <li class="fragment">
              will always be <b>completely re-rendered</b> on data change (no 2-way-data-binding)
            </li>
            <li class="fragment">will be aggregated to <b>complete applications</b></li>
          </ul>
        </section>

        <section>
          <h3>React Components</h3>
          <ul>
            <li class="fragment">
              Components are written either as <b>JS functions with "Hooks"</b> or as
              <b>ES6 classes</b>
              <ul>
                <li>
                  Hooks is newer React API (since Version 16.8, February 2019) an "future of React"
                </li>
                <li>Classes still widespread in existing code, documentation, tutorials etc</li>
              </ul>
            </li>

            <li class="fragment">
              No Template Language
              <ul>
                <li>We write our UI completely in JavaScript</li>
                <li>
                  React provides a language add-on for JavaScript allowing you to write HTML-like in
                  JS (called JSX)
                </li>
                <li>(Isn't that a template language?)</li>
              </ul>
            </li>
          </ul>
        </section>

        <section>
          <h3>Our first component: Hello, World!</h3>
          <ul>
            <li>Example Step-by-Step (<code>blog-example/workspace</code>)</li>
          </ul>
        </section>

        <section id="interaktiv-hellomessage">
          <h3>Hello World React</h3>
          <code>HelloWorld.js</code>
          <pre><code data-trim contenteditable>
  import React from "react";
  
  export default function HelloWorld(props) {
    const [title, setTitle] = React.useState("");
  
    return (
      &lt;div>
        &lt;input onChange={event => setTitle(event.target.value)} value={title} />
  
        &lt;p>Title: {greeting}&lt;/p>
        &lt;button onClick={() => setTitle("")}>Clear&lt;/button>
      &lt;/div>
    );
  }
            </code></pre>
        </section>

        <section>
          <h3>Embedding your Application</h3>
          <div class="fragment">
            <p>
              <code>index.html</code>
            </p>
            <pre><code data-trim contenteditable>
  &lt;html>
    &lt;-- ... -->
    &lt;body>
      <div id="root"></div>
    &lt;/body>
  &lt;/html>
  </code></pre>
          </div>
          <div class="fragment">
            <p>
              <code>index.js</code>
            </p>
            <pre><code data-trim contenteditable class="javascript">
  import React from 'react';
  import ReactDOM from 'react-dom';
  
  import HelloWorld from './HelloWorld';
  
  ReactDOM.render(&lt;HelloWorld />, 
    document.getElementById('root')
  );
  </code></pre>
          </div>
        </section>
        <section>
          <h3>React: JSX</h3>
          <ul>
            <li style="font-size: 80%" class="fragment">
              Written like HTML code, incl. attributes:
              <pre><code class="xml" contenteditable data-trim>
&lt;div>&lt;input type="text"/>&lt;/div>
                    </code></pre>
            </li>
            <li style="font-size: 80%" class="fragment">
              Attention! <code>class</code>-attribute is called <code>className</code>:
              <pre><code class="xml" contenteditable data-trim>
                        &lt;h1 className="title">...&lt;/h1>
                    </code></pre>
            </li>
            <li style="font-size: 80%" class="fragment">
              Attributes, that are not string, have to be surrounded by {}:
              <pre><code class="xml" contenteditable data-trim>
&lt;Counter label="Count" count={7} showValues={true} />
                    </code></pre>
            </li>
            <li style="font-size: 80%" class="fragment">
              You can use pure javascript expressions in {}:
              <pre><code class="xml" contenteditable data-trim>
const title = 'Hello, World';
&lt;h1>{title.toUpperCase()}&lt;/h1>
                    </code></pre>
            </li>

            <li style="font-size: 80%" class="fragment">
              CSS styles are specified using an object (with keys in Camel-Case-Notation):
              <pre><code class="xml" contenteditable data-trim>
const styles = { marginLeft: '10px', border: '1px solid red' };
&lt;h1 style={styles}>...&lt;/h1>
                    </code></pre>
            </li>
          </ul>
        </section>
        <section>
          <h3>React: JSX #2</h3>
          <ul>
            <li style="font-size: 80%" class="fragment">
              Fragments (A Fragment does not render something, only it's children):
              <pre><code class="xml" contenteditable data-trim>
function Choice() { 
  return &lt;&gt;
    &lt;li>Yes&lt;/li> 
    &lt;li>No&lt;/li>
  &lt;/>              
}  
                    </code></pre>
            </li>
            <li style="font-size: 80%" class="fragment">
              Use null, false or any boolean, to not render anything:
              <pre><code class="xml" contenteditable data-trim>
function ErrorMessage(props) {
  if (!props.msg) {
    return null; // or false or true
  }

  return <h1>Error: {props.msg}</h1>;
}              
                    </code></pre>
            </li>

            <li style="font-size: 80%" class="fragment">
              Comments in JSX
              <pre><code class="xml" contenteditable data-trim>
  function MyComponent() {
    return <div>
      { /* this ist javascript, and block comments are allowed here */ }
    </div>;
  }              
                      </code></pre>
            </li>
          </ul>
        </section>

        <section>
          <h3>React: Properties und State</h3>
          <ul class="fragment">
            <li>
              <b>Properties</b> are passed into the components from the <b>outside</b>, from the
              caller of the component. Properties <b>must not be changed</b> by the component.
            </li>
            <li class="fragment">
              <b>State</b> is an <b>internal</b> property of a component. State
              <b>might be changed</b> only by the component iself.
            </li>
          </ul>
        </section>

        <section>
          <h3>Properties ("Props") of a component</h3>

          <ul>
            <li class="fragment">
              ...are JavaScript objects (key-value-pairs)
            </li>
            <li class="fragment">
              ...are the first argument of a component function
            </li>
            <li class="fragment">must not be changed by the receiving component</li>
          </ul>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
            function Header(props) {
                return (
                  &lt;h1 style={{color: props.titleColor}}>{props.title}&lt;/h1>
                );
              }
            }
            </code></pre>

          <pre class="fragment"><code class="javascript" contenteditable data-trim>
// You can use destructuring for better (?) readabilty: 
function Header({titleColor, title}) {
    return (
      &lt;h1 style={{color: titleColor}}>{title}&lt;/h1>
    );
  }
}
                </code></pre>
        </section>

        <section>
          <h3>State of a component: useState-Hook</h3>
          <ul>
            <li>
              Example: Contents of a text field, data from server, is a menu expanded or collapsed
            </li>
            <li class="fragment">
              <b>Values</b> normally immutable. (in many cases we have primitive data types as
              values, so state is automatically immutable)
            </li>
            <li class="fragment">Working with state using the <b>useState</b>-Hook</li>
            <li class="fragment">
              useState returns an array with two entries: 1. the state's current value, 2. a
              setter-function used to change the state
            </li>
          </ul>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
function HelloWorld(props) {
  const [title, setTitle] = React.useState("");

  return &lt;input onChange={e => setTitle(e.target.value) value={title} />;
}
                  </code></pre>
          <ul>
            <li class="fragment">
              Calling the setter function <b>forces re-rendering the <i>whole</i> component</b> (and
              all children!)
            </li>
            <li class="fragment">
              You can use multiple independent states, by calling using multiple useState calls
            </li>
            <li class="fragment">
              <b>State</b>, its behaviour and organization is one of the <b>fundamental</b> concepts
              of React
            </li>
          </ul>
        </section>
        <section>
          <h3>React Hooks</h3>
          <em
            >Hooks are JS functions that let you "hook into" the lifecycle of a React component
          </em>
          <ul>
            <li class="fragment">
              Hooks are "normal" JS functions, but must start with <code>use</code> (useState,
              useEffect, ...)
            </li>
            <li class="fragment">
              Example: Importing and using Hooks

              <pre><code class="javascript" contenteditable data-trim>
// default import only
import React from "react";
function HelloWorld(props) {
  const [title, setTitle] = React.useState("");
  // ...
}
                                  </code></pre>
              <pre class="fragment"><code class="javascript" contenteditable data-trim>
// Default and named import
import React, { useState } from "react";

function HelloWorld(props) {
  const [title, setTitle] = useState("");
  // ...
}
                                                        </code></pre>

              <ul>
                <li class="fragment">
                  (Note! <code>React</code> has to be always <b>imported</b> when you use JSX in
                  your source code!)
                </li>
              </ul>
            </li>
          </ul>
        </section>
        <section>
          <h3>React Hooks</h3>
          <em>You have to follow some rules when using Hooks ðŸ‘†</em>
          <p style="font-size:75%;margin-top:0">
            <a href="https://reactjs.org/docs/hooks-rules.html"
              >(https://reactjs.org/docs/hooks-rules.html)</a
            >
          </p>
          <div class="fragment">
            <p>Restrictions:</p>
            <ul>
              <li class="fragment">
                Hooks can only be used in functional components and other Hook functions. They
                cannot be used in React Class Components.
              </li>
              <li class="fragment">
                Inside a component, Hooks must be used always in the same order across render cycles
                and only on top-level (examples following soon).
                <ul>
                  <li>Hooks are not allowed in loops, if-statements or other functions/closures</li>
                </ul>
              </li>
              <li class="fragment">
                There is a
                <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks">ESLint Plug-in</a>
                that ensures correct usage of hooks (automatically configured in create-react-app
                projects)
              </li>
            </ul>
          </div>
          <p class="fragment">
            <em
              >Internally React remembers the <b>order</b> of the invoked hook functions of a
              component to assign their correct values on later re-renderings!</em
            >
            >
          </p>
        </section>
        <section>
          <h3>React Hooks</h3>
          <em>Examples of correct and incorrect usage</em>

          <pre class="fragment"><code class="javascript" contenteditable data-trim>
// ALLOWED:
function HelloWorld(props) {
  const [greeting, setGreeting] = React.useState("");
  const [name, setName] = React.useState("");
  // ...
}
                                </code></pre>

          <pre class="fragment"><code class="javascript" contenteditable data-trim>
// ALLOWED:
function HelloWorld(props) {
  const [greeting, setGreeting] = React.useState(props.initialGreeting);
  const uppercaseGreeting = greeting.toUpperCase(); 
  const [name, setName] = React.useState(props.initialName);
  // ...
}
                                                      </code></pre>

          <pre class="fragment"><code class="javascript" contenteditable data-trim>
// FORBIDDEN:
function HelloWorld(props) {
  const [greeting, setGreeting] = React.useState("");
  if (greeting !== null) {
    const [name, setName] = React.useState("");
  }
  // ...
}
                                                      </code></pre>

          <pre class="fragment"><code class="javascript" contenteditable data-trim>
// FORBIDDEN:
function HelloWorld(props) {
  if (props.currentUser === null) {
    return &lt;h1>Please login first&lt/h1>
  }
  const [greeting, setGreeting] = React.useState(props.initialGreeting);
  return &lt;input value={greeting} ... />
}
                                            </code></pre>
        </section>
        <section>
          <h3>React Hooks</h3>
          <em>Examples of correct and incorrect usage</em>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
              // FORBIDDEN 
              function HelloWorld(props) {
                function initState() {
                  return React.useState(props.initialGreeting);
                }
                const [greeting, setGreeting] = initState();
              }
            </code></pre>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
                // FORBIDDEN (initState is a 'normal' function, 
                //  should be useInitState instead)
                function initState() {
                  return React.useState(props.initialGreeting);
                }

                function HelloWorld(props) {
                  const [greeting, setGreeting] = initState();
                }
              </code></pre>
        </section>

        <section>
          <h3>Render Cycle</h3>
          <img src="slides/images/render-cycle.png" height="550px" />
        </section>

        <section>
          <h3>Virtual DOM</h3>
          <p>"Rendering" has two meanings!</p>
          <img src="slides/images/vdom.png" style="height:650px" />
        </section>

        <section>
          <h3>Lists</h3>
          <p>JSX has no explicit support for lists</p>
          <p>
            In most cases,
            <code>Array.map()</code> is used to map a list of objects to a list of JSX elements
          </p>
          <p>Each element in a list needs a <em>list-wide unique key</em></p>

          <pre class="fragment"><code class="javascript" contenteditable data-trim>
const posts = [
  { id: 0, title: 'Hello World', body: 'Lorem ipsum' },
  { id: 1, title: 'React in a Nutshell', body: 'Lets get started with React' }
];

function PostList(props) {
  return {props.posts.map(post => (
    &lt;div key={post.id}>
        &lt;h1>{post.title}&lt;/h1>
        &lt;p>{post.body}&lt;/p>
    &lt;/div>
  )}
}
</code></pre>
        </section>

        <section>
          <h2>Component hierarchies</h2>
        </section>
        <section>
          <h2 class="todo">mehr Ã¼bernehmen aus vollstÃ¤ndigen Workshops</h2>
        </section>
        <section>
          <h3>Data flow in React application</h3>
          <ol>
            <li>
              In React applications, components are composed in hierarchies to become applications
              (an application is just a bunch of components)
            </li>
            <li class="fragment">
              Inside the hierarchy communication is always in one direction only:
              <b>Parent</b> components pass down <b>properties</b> to their <b>children</b>
            </li>
            <li class="fragment">
              Using the properties Data (blog post, currently logged in user, ...) can be passed
              from "top" to "bottom". This can be done across more than one level in the hierarchy.
              <p>
                (A component can pass all or parts of the properties it receives itself to its
                children)
              </p>
            </li>
            <li class="fragment">
              Using properties, <b>callback functions</b> can also be passed down
            </li>
            <li class="fragment">
              A child component can invoke this function to send and event (with or without) data to
              their parent component <br />We have seen this already with the onChange property on
              the input-field)
            </li>
          </ol>
        </section>

        <section>
          <h3>Smart and Dumb-Components #1</h3>

          <p>
            Reminder: in React we build components. Components consist of logic, state and UI
            (HTML-Elements and Styling)
          </p>
          <p class="fragment">
            In a well-known pattern components are spilt into "smart" (or "controller") and "dumb"
            (or "presentation") components.
          </p>
          <p class="fragment">
            Technically both components are identical, both are regular React components
          </p>
          <p class="fragment">
            Only their <b>intended purpose</b> or role is defined differently...
          </p>
        </section>

        <section>
          <h3>Smart and Dumb components #2</h3>
          <p><b>Smart components</b> contain logic and state, but (almost) no UI</p>
          <p><b>Dumb components</b> only present/render the data</p>
          <ol>
            <li class="fragment">
              Smart components <b>manage the state</b> and pass it into Dumb components. Dump
              components <b>render the state</b>.
            </li>
            <li class="fragment">
              Smart components pass callback functions as Event-Handler into the dumb components.
            </li>
            <li class="fragment">
              When an event occures inside a dumb component, (for ex. button click or text input)
              the dumb components invokes the callback function.
            </li>
            <li class="fragment">
              The callback function is executed inside the context of the smart component (normal
              closure behaviour) and thus can acess state etc from the smart component.
            </li>
            <li class="fragment">
              Inside the event handler, state of the smart component can be changed. Chaning the
              state leads to re-rendering of the smart component and all of its children (dumb)
              components.
              <br /><b>The app state remains consistent across all components in the hierarchy</b>
            </li>
          </ol>
        </section>

        <section data-markdown data-transition="none">
          <textarea data-template>
    ### Communication between several parts of our application
    
    <img src='slides/images/smart-dumb-1.png' height="600">
                    </textarea
          >
        </section>

        <section data-markdown data-transition="none">
          <textarea data-template>
    ### Communication between several parts of our application
    
    <img src='slides/images/smart-dumb-2.png' height="600">
                    </textarea
          >
        </section>

        <section data-markdown data-transition="none">
          <textarea data-template>
    ### Communication between several parts of our application
    
    <img src='slides/images/smart-dumb-3.png' height="600">
                    </textarea
          >
        </section>

        <section data-markdown data-markdown data-transition="none">
          <textarea data-template>
    ### Communication between several parts of our application
    
    <img src='slides/images/datenfluss-4.png' height="550">
    
    Strict data- and control flow    
                      </textarea
          >
        </section>

        <section>
          <h3>Example</h3>

          <p>
            Our <b>smart component</b> holds a list of Blog Posts and deceides, which view is active
            (Editor or List) ist
          </p>
          <p>
            The smart components passes the list of blog posts to the BlogList component for
            rendering
          </p>
          <p>
            The smart components passed a callback function to BlogList and AddForm to get informed
            about events/data changes
          </p>

          <pre><code>
function App() {
  const [posts, setPosts] = React.useState([]);
  const [view, setView] = React.useState("list");

  function addPost(newPost) {
    // Add the new post to the state
    setPosts([...posts, newPost]);

    // switch back to list view
    setView("list");
  }

  if (view === "list") {
    return &lt;BlogList posts={posts} onAdd={() => setView("addForm")} />
  }

  return &lt;AddForm onAdd={addPost} />

}            
</code></pre>
        </section>

        <section>
          <h3>Example #2</h3>

          <p>
            The BlogList is responsible for rendering the list of posts only. If the add button gets
            pressed, the component invokes the callback function (received from the App component).
          </p>
          <p>The callback function changes the App state to make the Post Editor visible</p>

          <pre><code>
  function BlogList(props) {

    return &lt;div>
      // ... render the blog post list ...
      &lt;button onClick={props.onAdd}>Add Blog Post&lt;/button>
    &lt;/div>;
  }            
  </code></pre>
        </section>

        <section>
          <h3>Example #3</h3>

          <p>
            The AddForm component passes the new blog post (its internal state) to the callback
            function, that it has received from the App component.
          </p>
          <pre><code>
  function AddForm(props) {
    const [title, setTitle] = React.useState("");
    const [body, setBody] = React.useState("");

    function addPost() {
      const newPost = {
        title, body
      }

      // Inform the App component about the new blog post
      props.onAdd(newPost);
    }

    return &lt;div>
      // ... Render form ...
      &lt;button onClick={addPost}>Save Post&lt;/button>
    &lt;/div>;
  }            
  </code></pre>
        </section>

        <section id="server">
          <h1>Server Access</h1>
          <em>Read and write data from a backend (REST/HTTP)</em>
        </section>

        <section>
          <h3>The blog Backend</h3>
          <p>
            The backend is already implemented. You can started it:
          </p>
          <pre><code>
                  cd react-training/blog-example/backend-rest
                  npm start
                </code></pre>
          <p>The server runs on port 7000</p>
          <p>
            You can test it in your browser (or wget, curl) with this URL:
            <a href="http://localhost:7000/posts">http://localhost:7000/posts</a>
          </p>
        </section>

        <section>
          <h3>Background: API of the Blog Backend Server</h3>
          <p>
            HTTP Endpoints:
          </p>
          <p><b>GET /posts</b> Return all blog posts</p>
          <p><b>GET /posts/:id</b> Read a single blog post</p>
          <p>
            <b>POST /posts</b> Create a new blog post. Payload must be an object with
            <code>title</code> and <code>string</code> properties. As result you receive the
            complete new blog post (including it's unique id and the date)
          </p>
          <p><b>DELETE /posts/:id</b> Remove a blog post</p>
          <p>
            You can add the query parameter <b>?slow</b> to all backend URLs to simulate a long
            running server operation (for example if you want to see loading states in your
            application)
          </p>
        </section>

        <section id="t4">
          <h1>Part IV</h1>
          <h2>Reading and writing data from a server</h2>
          <a href="code/schritte/3-remote/public/index.html" target="_blank">Ziel-Anwendung</a>
        </section>

        <section>
          <h3>Challanges</h3>
          <ol>
            <li>How do we access a remote API?</li>
            <li>How do we deal with asynchronous code in React?</li>
          </ol>
        </section>

        <section>
          <h3>Server-Calls</h3>
          <ul>
            <li>React is not opinonated about how to do server calls</li>
            <li class="fragment">
              Often used in React applications: <b>fetch</b> API
              <ul>
                <li>Standard browser API for executing HTTP requests</li>
                <li>
                  <a href="http://caniuse.com/#search=fetch" target="_blank">wide support</a>
                </li>
                <li>
                  Specification:
                  <a href="https://fetch.spec.whatwg.org/" target="_blank"
                    >https://fetch.spec.whatwg.org/</a
                  >
                </li>
                <li>
                  Polyfill for older browsers:
                  <a href="https://github.com/github/fetch" target="_blank"
                    >https://github.com/github/fetch</a
                  >
                </li>
              </ul>
            </li>
          </ul>
        </section>

        <section>
          <h3>Example: fetch</h3>
          <p>Read data with HTTP GET using async/await</p>
          <pre><code class="javascript" contenteditable data-trim>
          // For GET simply specify the URL:
          try {
            const response = await fetch('http://localhost:7000/posts')
            const json = await response.json();
            // ...
          } (catch ex) {
            console.error('request failed', ex)
          }
          </code></pre>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
// or use JavaScript Promise API:

fetch('http://localhost:7000/posts')
  .then(response => response.json())
  .then(json => /* ... */)
  .catch(ex => console.error('request failed', ex));
</code></pre>
        </section>
        <section>
          <h3>Example #2: fetch</h3>
          <p>Read data with HTTP POST</p>
          <div class="fragment">
            <p>
              <code>fetch</code> expects a second parameter containing an object with configuration:
            </p>

            <ul>
              <li>
                <code>method</code>: specifies the HTTP method to use (<code>PUT</code>,
                <code>POST</code>, <code>DELETE</code>, ...)
              </li>
              <li>
                <code>headers</code>: HTTP headers for the request (for example Authorization)
              </li>
              <li><code>body</code>: The request payload (as string)</li>
            </ul>
            <p>The return value is the same as we've seen with GET</p>
          </div>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
const response = await fetch(url, {
  method: 'POST',
  headers: {
    'Accept': 'application/json',
    'Content-Type': 'application/json'
  },
  body: JSON.stringify(payload)
})
// ... 
    </code></pre>
        </section>

        <section data-state="es6-exkurs">
          <h2>Background: Promises and async/await</h2>
        </section>

        <section>
          <h3>Promises</h3>
          <p>
            A <b>promise</b> object represents the eventual result of an asynchronous operation (or
            its failure)
          </p>

          <pre class="fragment"><code class="javascript" contenteditable>
              // A Promise that prints 'Klaus' after one second:
              new Promise(
                resolve => setTimeout( () => resolve("Klaus"), 1000)
              ).then(name => console.log(name))
                </code></pre>
        </section>

        <section>
          <h3>Chained execution</h3>

          <pre><code class="javascript" contenteditable>
// A Promise that resolves the string 'Klaus' after one second:
const promise = new Promise(
  resolve => setTimeout( () => resolve("Klaus"), 1000)
)
  </code></pre>
          <pre
            class="fragment"
          ><code class="javascript" contenteditable>// 'then' always returns another Promise!
const promise2 = promise.then(name => `Hello, ${name}`);</code></pre>
          <pre
            class="fragment"
          ><code class="javascript" contenteditable>promise2.then(greeting => console.log(greeting));
// Output after one second: "Hello, Klaus"
  </code></pre>
        </section>
        <section>
          <h3>Errors will interrrupt the promise chain</h3>
          <h4>But you <b>must</b> do something to get informed: catch()</h4>
        </section>

        <section>
          <h3>Catch in cases of an error</h3>
          <pre><code class="javascript" contenteditable>
  const promise = new Promise( /* as seen above */ )
    .then(name => {throw new Error("Unexpected Error") })
    .then(greeting => console.log(greeting));
    .catch(error => console.error(`Greeting failed: ${error}`))
  
    // Output: Greeting failed: Unexpected error
    </code></pre>
        </section>

        <section>
          <h3>More on Promises</h3>
          <h4 class="fragment">Create a promise</h4>
          <pre class="fragment"><code class="javascript" contenteditable>
const p = new Promise(resolve => { ... }, error => { ... });            
  </code></pre>
          <h4 class="fragment">Creation II</h4>
          <pre class="fragment"><code class="javascript" contenteditable>
// Will be resolved immediatley 
const p = Promise.resolve("Klaus");            
</code></pre>
          <h4 class="fragment">Awaiting multiple Promises</h4>
          <pre class="fragment"><code class="javascript" contenteditable>
Promise.all( [p1, p2] )
  .then( (result1, result2) => {
    console.log(`All promises resolved: ${result1} ${result2}`);
  });
</code></pre>
        </section>

        <section>
          <h3>Promises: asynchronous control flow</h3>
          <pre><code class="javascript" contenteditable>
console.log("1");

const p = new Promise.resolve("Klaus")
    .then(name => `Hello, ${name}`)
    .then(greeting => console.log(greeting));

console.log("2");    
    </code></pre>
          <p>Question to you: how does the console output looks like? ðŸ¤”</p>
        </section>

        <section>
          <h2>async / await</h2>
          <p>"wrapper" around promises</p>
          <p>Allows you to write asynchronous code in a "linear" style</p>
          <ul class="fragment">
            <li>Since ECMASCript 2017 Standard</li>
          </ul>
        </section>
        <section data-state="es6-exkurs">
          <h3>async / await</h3>
          <p><code>await</code> waits until a Promise gets resolved</p>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
    function greet(name) { return new Promise(...); }
    
    // await can only be used in 'async'-functions:
    async function sayWhat(name) {
      const greeting = await greet(name);
    
      // greeting is a string!
      console.log(greeting); // => Hello, ...
    }
                      </code></pre>
        </section>
        <section>
          <h3>async / await</h3>
          <p><code>async</code> declares a function as an "async function"</p>
          <p class="fragment">
            An <code>async</code> functions &nbsp; <b>always</b> returns a Promise
          </p>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
  async function greet(name) {
    return `Hello, ${name}`;
  }
  
  const greeting = greet('Klaus');
  
  // greeting is a Promise!
  console.log(greeting instanceof Promise); // => true
  console.log(greeting) // => Promise {&lt;resolved>: "Hello, Klaus"}
                  </code></pre>
          <p class="fragment"><code>async</code> function as fat arrow function:</p>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
  const greet = async (name) => `Hello, ${name}`;                
    
  const greeting = greet('Klaus');
    
  // greeting is a promise!
  console.log(greeting instanceof Promise); // => true
  console.log(greeting) // => Promise {&lt;resolved>: "Hello, Klaus"}
                    </code></pre>
        </section>

        <section data-state="es6-exkurs">
          <h3>async / await</h3>
          <p>
            Instead of <code>then</code> or <code>catch</code> you can simply chain multiple
            <code>await</code> statements and use try/catch for exception handling:
          </p>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
  // Return promises
  async function loadUser(username) { . . . };
  async function loadProfileDate(userId) { . . .};
  
  async function loadData() {
    try {
      const user = await loadUser('klaus');
      const profile = await loadProfileData(user.userId);
    } catch (e) {
      console.error("Something failed")
    }
  }
                      </code></pre>
        </section>

        <section>
          <h3>fetch: Details</h3>

          <pre><code class="javascript" contenteditable data-trim>
  try {
    // 1. fetch returns a Promise, that will be resolved with a
    // Response object when the answer from the server comes in
    const response = await fetch('http://localhost:7000/posts');
  
    // 2. the Response object contains "meta data" about the Response
    // (for ex. http status code) and functions the read the payload,
    // for example from JSON:
    const posts = await response.json();
  
    // btw: What do we do with the answer here in our React application?
    // ???
  } catch (err) {
    // 4. In case something goes wrong, log error
    console.error('request failed', err);
  }
  
  </code></pre>
          <p>
            <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch API Doku</a>
          </p>
        </section>

        <section>
          <h3>When will we load the data (blog posts) for our application?</h3>
        </section>

        <section>
          <h3 class="todo">Initiales Laden von Daten</h3>

          <p>
            Schritt-fÃ¼r-Schritt (<code
              >code/workspace-live-coding, vorher schritte/2-hierarchy reinkopieren</code
            >)
          </p>
        </section>

        <section>
          <h3>Fetch-on-Render</h3>
          <p>We can trigger the server call when rendering our component</p>
          <p>
            Until the data is available (during the server call) we show a loading indicator to the
            user
          </p>
        </section>

        <section>
          <h3>Side-effects</h3>
          <p>
            Server calls are <b>side-effects</b> (other examples: manipulating the DOM, opening a
            WebSocket)
          </p>
          <p>Side-effeects are forbidden during the render phase of a component!</p>
        </section>

        <section>
          <h3>useEffekt-Hook</h3>
          <p>
            <em
              >With useEffect you can register an effect (function) that is run after rendering</em
            >
          </p>

          <pre class="fragment"><code class="javascript" contenteditable data-trim>
            function App(props) {
              React.useEffect( 
                () => console.log("I will run after EACH render")
              );
            }
          </code></pre>

          <div class="fragment">
            2. Parameter (array) determines, when the Hooks will run ("dependencies")

            <pre class="fragment"><code class="javascript" contenteditable data-trim>
              function App(props) {
                React.useEffect( 
                  () => console.log("I will run only once after 1st rendering"),
                  []
                );
              }
            </code></pre>
          </div>

          <div class="fragment">
            Only run after 1st rendering an when postId changes:

            <pre class="fragment"><code class="javascript" contenteditable data-trim>
                function App(props) {
                  React.useEffect(
                    () => console.log("..."), 
                    [props.postId]) 
                  );
                }
              </code></pre>
          </div>
        </section>

        <section>
          <h3>useEffect Hook</h3>

          <p>Two parameters:</p>
          <ol>
            <li class="fragment">
              A callback function, that is called after the rendering
            </li>
            <li class="fragment">
              An Array with <b>dependencies</b>:
              <ul>
                <li class="fragment">
                  If you skip this argument, your function will executed after
                  <b>each rendering</b>. Be careful about endless recursions
                </li>
                <li class="fragment">
                  If the dependencies array is empty, the effect will run only once, after the first
                  rendering of your component
                </li>
                <li class="fragment">
                  If there are values in the array the effect will run after the 1st rendering and
                  after any rendering when one of the values have been changed in between
                </li>
              </ul>
            </li>
          </ol>
        </section>

        <section>
          <h3>Example: Initial loading of data</h3>

          <div>
            <p>
              <code>useEffect</code> und (<code>useState</code>) will be used to load data after 1.
              rendering
            </p>
            <pre><code class="javascript" contenteditable data-trim>
                function App() {
                  const [posts, setPosts] = React.useState([]);
                
                  React.useEffect(() => {
                    fetch("http://localhost:7000/posts")
                      .then(response => response.json())
                      .then(json => setPosts(json));
                  }, []);

                  return {posts.map(p => (
                    &lt;Post key={p.id} post={p} />
                  ))}
                }
                
                </code></pre>
          </div>
        </section>

        <section>
          <h3>Example: Initial loading of data #2</h3>

          <p>Lifecycle of this example (App component):</p>
          <ol>
            <li class="fragment">
              Component function App is executed (Component will be "rendered")
            </li>
            <li class="fragment">State is initialized with an empty array</li>
            <li class="fragment">The effect (loading the data) is registered</li>
            <li class="fragment">
              UI-Code is returned by the function (in this case an empty lists, as no posts have
              been loaded yet)
            </li>
            <li class="fragment">React creates the native DOM for the UI</li>
            <li class="fragment">React runs the registered Effect, the Server-Call starts</li>
            <li class="fragment">
              Somewhen later: the server call returns, the received data are set into the state
            </li>
            <li class="fragment">
              Updating the state leads to re-rendering of the App component. React invokes the
              function again.
            </li>
            <li class="fragment">The App's state is now the array with the received data</li>
            <li class="fragment">The effect won't run again (empty array as 2. parameter)</li>
            <li class="fragment">
              The component returns the UI for the populated list with blog posts
            </li>
          </ol>
        </section>

        <section>
          <h3>Saving of data</h3>
          <p>For example after a user interaction:</p>
          <p class="fragment">Inside an Event Handler it is allowed to use side effects!</p>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
function App(props) {
  // load, as seen
  React.useEffect( ... );

  function addPost(post) {
    fetch("http://localhost:7000/posts", {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify(post)
    })
      .then(response => response.json())
      .then(newPost => setPosts([newPost, ...posts]));
  }


  return
    ...
      &lt;AddPost onAdd={newPost => addPost(newPost)} />
    ...
}
                </code></pre>
        </section>

        <section>
          <h2 class="todo">Ãœbung: Laden und Speichern der Daten von/auf einem Server</h2>
          <p>
            <em
              >Entwickle auf Basis von fetch eine Version des GreetingControllers, der die Daten auf
              dem Server laden und dort wieder speichern kann</em
            >
          </p>
          <p>
            Der Server ist bereits fertig. Zum Starten:
          </p>
          <pre><code>
                cd react-training/code/server
                npm start
              </code></pre>
          <p>Der Server ist Ã¼ber Port 7000 erreichbar</p>
          <p>
            Zum Testen:
            <a href="http://localhost:7000/greetings">http://localhost:7000/greetings</a>
          </p>
        </section>
        <section>
          <h3 class="todo">Schritte</h3>
          <ol class="x-list">
            <li class="fragment">
              Kopiere <code>code/material/3-remote/GreetingController.js</code> in deinen
              Arbeitsbereich
            </li>

            <li class="fragment">
              Die Serverzugriffe sollen in <code>loadGreetings</code> und
              <code>saveGreeting</code> erfolgen
              <ul>
                <li>Dort sind bereits entsprechende TODOs fÃ¼r dich eingetragen</li>
                <li>
                  Die URL des Backends steht in der Konstante <code>BACKEND_URL</code>. <br /><code
                    >const BACKEND_URL = "http://localhost:7000/greetings";</code
                  >
                </li>
              </ul>
            </li>

            <!-- <li class="fragment">
              Optional 1: FÃ¼ge der loadGreetings-Methode eine Fehlerbehandlung zu. (Du kannst das
              Backend stoppen, um einen Fehler zu provozieren). Kannst Du eine Fehlermeldung in der
              UI anzeigen?
            </li>
            <li class="fragment">
              Optional 2: Kannst Du die saveGreeting-Funktion so extrahieren, dass sie auÃŸerhalb der
              GreetingController-Komponente stehen kann?
            </li> -->
          </ol>
        </section>

        <section id="t-router">
          <h2>Client-side Routing</h2>

          <p>Example: code/blog-example/steps/6-router</p>
        </section>
        <section>
          <h2>Why routing?</h2>
          <span>
            <p>
              Map URLs to Components
              <br />
              <span style="font-size: 80%"
                >(Navigation through the application without server round-trips!)</span
              >
            </p>
          </span>
          <span>
            <p>
              URLs can contain state of the application
              <br />
              <span style="font-size: 80%"
                >What "Page" is visible (Blog List, Add Form or Blog Post)?</span
              >
              <br />
              <span style="font-size: 80%">Which blog post should be rendered (postId)</span>
            </p>
          </span>
        </section>

        <section>
          <h2>React Router</h2>
          <ul>
            <li>
              Current version 5.1:
              <a href="https://reacttraining.com/react-router/" target="_blank">
                https://reacttraining.com/react-router/</a
              >
            </li>
            <li>Not part of React</li>
            <li>but de-facto Standard</li>
            <li>Since Version 5.1 with Hooks API (useParams, useLocation, useHistory)</li>
          </ul>
        </section>
        <section>
          <h3>The Router Object</h3>
          <p class="fragment">
            Top-Level object, that needs to be included at the top of the application's component
            hierarchy
          </p>
          <p class="fragment">
            Mulitple implementations that differ how they interact with URL and browser history:
          </p>
          <ul>
            <li class="fragment">
              <b>HashRouter</b>: adds the path after appended hash (#/post/1)
            </li>
            <li class="fragment">
              <b>BrowserRouter</b>: puts the path directly in the URL (/post/1)
            </li>
          </ul>
          <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
      import {HashRouter as Router} from "react-router-dom";
      
      const app = &lt;Router>&lt;App/>&lt;/Router>;
      
      ReactDOM.render(app, document.getElementById(...));
              </code></pre>
        </section>

        <section>
          <h3>Which component should be rendered for a path?</h3>
          <p class="fragment">The <code>Route</code> object maps paths to components</p>
          <ul>
            <li class="fragment">
              Can be used whereever you want to select a component based on a path
              <ul>
                <li>
                  comparable with an "intelligent" <code>if</code> or <code>switch</code> statement
                </li>
                <li>can be used everywhere in your components</li>
              </ul>
            </li>
            <li class="fragment">
              Use the <code>path</code> attribute to specify the path that should match when the
              component should be rendered
            </li>
            <li class="fragment">Specify the component as children of the Route component</li>
          </ul>
          <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
      import {HashRouter as Router, Route} from "react-router-dom";
      
      const app = &lt;Router>
        &lt;Route path="/post/:postId">&lt;BlogPostPage />&lt;/Route>
        &lt;Route path="/add">&lt;AddPostPage onAdd={...} />&lt;/Route>
        &lt;Route path="/" exact>&lt;BlogListPage />&lt;/Route>
      &lt;/Router>;
      
      ReactDOM.render(app, document.getElementById(...));
              </code></pre>
        </section>

        <section>
          <h3>Background: Paths</h3>
          <p>
            In the Route component you specify a <b>path</b>, that is compared against the current
            URL
          </p>

          <ul>
            <li>
              Paths by default are valid for parts of strings, but you can change the behaviour by
              adding <code>exact</code>
            </li>
            <li>A Route without <code>path</code> matches always</li>
          </ul>
          <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
      // matches  / and /post
      &lt;Route path="/">...&lt;/Route>
      
      // matches only /
      &lt;Route path="/" exact>...&lt;/Route>
      
      // matches any URL:
      &lt;Route>...&lt;/Route>
      
              </code></pre>
          <ul>
            <li class="fragment">A Path can contain variable segments:</li>
          </ul>
          <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
      &lt;Route path="/posts/:postId">&lt;BlogPostPage/>&lt;/Route>
           </code> </pre>
          <ul>
            <li class="fragment">
              Values of the variables can be read using the <code>useParams</code> hook in your
              component:
            </li>
          </ul>
          <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
                import { useParams } from "react-router";

                function BlogPostPage() {
                  const params = useParams();

                  // params.postId contains the id from the URL
                </code></pre>
        </section>
        <section>
          <h3>Switch</h3>
          <ul>
            <li class="fragment">
              If multiple path expression match, multiple components will be rendered (for example
              "/" and "/post")
            </li>
            <li class="fragment">
              <code>Switch</code> ensures that only the fÃ¼r component will be rendered (like regular
              switch with a break after each case)
            </li>
          </ul>
          <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
      import {HashRouter as Router, Route, Switch} from "react-router-dom";
      
      const app = (
        &lt;Router>
          &lt;Switch>
            &lt;Route path="/post/:postId">&lt;BlogPostPage />&lt;/Route>
            &lt;Route path="/" exact>&lt;BlogListPage/>&lt;/Route>
      
            // "No match": without path
            &lt;Route>&lt;NotFoundPage/>&lt;/Route>
      
          &lt;/Switch>
        &lt;/Router>
      );
      
      ReactDOM.render(app, document.getElementById(...));
              </code></pre>
        </section>

        <section>
          <h3>Links</h3>
          <p>
            Using the <code>Link</code> or <code>NavLink</code> component you can create HTML links
          </p>
          <ul>
            <li>Use <code>to</code> to specify the target path</li>
            <li>Link creates an <code>a</code> HTML element</li>
            <li>
              "Local" URLs will be rendered according to the selected Router implementation (with
              hash or without)
            </li>
            <li>
              With <code>activeClassName</code> and <code>activeStyle</code> on
              <code>NavLink</code> you can specify styles and classnames that get applied if the
              current route is the same route as specified in "to" ("active" route)
            </li>
          </ul>

          <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
      import {Link, NavLink} from "react-router-dom";
      
      &lt;Link to='/'>Show all Posts&lt;/Link>
      
      // Generted 'a' element contains 'highlight' CSS class, when it's the active route
      &lt;NavLink to='/add' activeClassName="highlight">Add Post&lt;/NavLink>
      
              </code></pre>
        </section>

        <section>
          <h3>The history-Objekt</h3>
          <p>The <code>history</code> object can be used to interact with the Browser history</p>
          <p>
            You can jump to another location or get the current location from the browser
          </p>
          <p class="fragment">
            The history object is available using the <code>useHistory</code> hook from React Router
          </p>
          <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
      import { useHistory } from "react-router";

      function App() {
        const history = useHistory();

        function onAdd(newBlogPost) {
           ...

           // go to new URL
           history.push("/"); 
        }

        return ...;
      }
              </code></pre>
        </section>

        <section>
          <h2>That's all! ðŸ˜Š</h2>
          <h3>Thanks a lot for your participation!</h3>
          <p>
            Kontakt:
          </p>
          <p>Mail: <a href="mailto:nils@nilshartmann.net">nils@nilshartmann.net</a></p>
          <p>
            Web: <a href="https://nilshartmann.net" target="_blank">https://nilshartmann.net</a>
          </p>
          <p>
            Twitter: <a href="https://twitter.com/nilshartmann" target="_blank">@nilshartmann</a>
          </p>
        </section>
      </div>
    </div>

    <script src="slides/reveal.js/lib/js/head.min.js"></script>
    <script src="slides/reveal.js/js/reveal.js"></script>
    <script src="slides/reveal.js/lib/jquery-2.2.4.js"></script>
    <script src="slides/reveal-config.js"></script>
  </body>
</html>

<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">

  <title>React Training</title>

  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

  <link rel="stylesheet" href="reveal.js/css/reveal.css">
  <link rel="stylesheet" href="reveal.js/css/theme/solarized.css" id="theme">


  <!-- Code syntax highlighting -->
  <!-- <link rel="stylesheet" href="reveal.js/lib/css/zenburn.css"> -->
  <link rel="stylesheet" href="reveal.js/lib/css/github.css">
  <link rel="stylesheet" href="reveal.js/lib/font/google-fonts.css" >
  <style>

  .reveal {
    font-family: 'PT Sans', sans-serif;
  }

    .reveal h1 {
      font-family: "Lora", serif;
    }

    .reveal h2,
    .reveal h3,
    .reveal h4 {
      font-family: "PT Sans", sans-serif;
      font-weight: bold;
      color: rgb(127, 94, 56);
      text-transform: none !important;
    }

    .reveal em {
      font-family: "Lora", serif;
    }

    .right-img {
      margin-left: 10px !important;
      float: right;
      height: 500px;

      border:0;
      box-shadow:0 0 0 0;
    }

    .todo:before {
      content: 'TODO: ';
    }

    .todo {
      color: red !important;
    }

    code span.line-number {
      color: lightcoral;
    }

    .reveal pre {
      max-width: 1100px;
    }

    .reveal pre code {
      max-height: 1000px !important;
    }

    .reveal section img {
      border: 0;
      box-shadow: 0 0 0 0
    }

    /*rgb(196, 215, 240)*/

    html.exkurs body {
      background: rgb(252, 220, 185) url("images/es6-icon.png") no-repeat right bottom;
    }
  </style>

  <!-- Printing and PDF exports -->
  <script>
    var link = document.createElement('link');
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match(/print-pdf/gi) ? 'reveal.js/css/print/pdf.css' : 'reveal.js/css/print/paper.css';
    document.getElementsByTagName('head')[0].appendChild(link);
  </script>

  <!--[if lt IE 9]>
    <script src="reveal.js/lib/js/html5shiv.js"></script>
    <![endif]-->
</head>

<body>

  <div class="reveal">
    <!-- Any section element inside of this container is displayed as a slide -->
    <div class="slides">
      <section>
        <h3>React Workshop - Vorbereitung</h3>
        <p><b>INSTALLATION</b></p>
        <ol style="font-size: 85%">
          <li>
                <code>git clone https://github.com/nilshartmann/react-training.git</code>
              oder
                <code>git pull</code>
          </li>
          <li>Im geklonten Verzeichnis:
            <code>npm install</code>
          </li>
        </ol>
       
            <p><b>STARTEN</b></p>
            <ol style="font-size: 85%">
          <li>Server 1: Im geklonten Root-Verzeichnis:
            <code>npm run start-backend</code>
          </li>
          <li>Server 2: in neuem Terminal: <code>code/workspace</code>:
                <code>npm start</code>
          </li>
          <li>Browser öffnen:
            <a href="http://localhost:8080" target="_blank">http://localhost:8080</a>
          </li>
          <li>Wenn dort ein Hello-World-Text erscheint ist alles gut
        </ol>
        <p>Folien: Im geklonten Verzeichnis
          <code>2019_react_hooks.html</code>

          <br>oder: <a href="https://nilshartmann.github.io/react-training/2019_react_hooks.html#/">https://nilshartmann.github.io/react-training/2019_react_hooks.html</a>
        </p>
      </section>

      <section>
        <h2>
          <b>Einführung in React</b>
        </h2>
        <h4>
          <a href="http://nilshartmann.net" target="_blank">Nils Hartmann</a> /
          <a href="http://twitter.com/nilshartmann" target="_blank">@nilshartmann</a>
          /
          <a href="mailto:nils@nilshartmann.net" target="_blank">E-Mail: nils@nilshartmann.net</a>
        </h4>
      </section>


      <section>
        <h2>Inhalt</h2>
        <ul>
          <li>
            <a href="#/t0">Teil 0: React Überblick, Tooling und Build-Prozess</a>
          </li>
          <li>
            <a href="#/t1">Teil I: React-Komponenten (Grundlagen)</a>
          </li>
          <li>
            <a href="#/t2">Teil II: React-Komponenten: Details, Hierarchien und Anwendungen</a>
          </li>
          <li>
            <a href="#/t3">Teil III: Daten lesen und schreiben vom Server</a>
          </li>
          <li>
              <a href="#/t-test">Teil IV: Testen von React Anwendungen</a>
            </li>

            <li style="margin-top: 30px">
              <a href="#/t7">Ausblick/Diskussion</a>
              <ul style="font-size: 85%">
                <li><a href="#/t-redux">Architekturpattern: Flux / Redux</a></li>
                <li><a href="#/t-context">Context API</a></li>
                <li><a href="#/t-router">Client-seitiges Routing mit React Router</a></li>
                <li><a href="#/t-hooks">React Hooks API</a></li>
                <li><a href="#/t-typescript">React Anwendungen mit TypeScript entwickeln</a></li>
                <li>Einbinden von 3rd-Party-Libs</li>
              </ul>
            </li>
        </ul>
        <div style="font-size:80%">
          <p>
            <b>Jederzeit:</b> Fragen und Diskussionen!</p>
        </div>
      </section>

      <section id="example-app">
        <h2>Beispiel-Anwendung</h2>
        <a target="_blank" href="code/schritte/5-third-party/public/index.html">
          <img src="images/greeting-master-and-detail.png" style="height:650px" />
        </a>
      </section>

      <section id="t0">
        <h1>Teil 0</h1>
        <h2>React-Einführung und Build-Prozess</h2>
      </section>

      <section id="react">
        <h2>React</h2>
        <p>
          <a href="https://reactjs.org" target="_blank">https://reactjs.org</a>
        </p>
        <ul>
          <li class="fragment">Framework von und für Facebook</li>
          <li class="fragment">Eingesetzt u.a. von Microsoft, Paypal, Spotify uvm</li>
          <li class="fragment">Minimales API
          <li class="fragment">Minimales Feature Set
            <ul>
              <li>Ihr könnt/müsst viele Entscheidungen selber treffen</li>
            </ul>
          <li class="fragment">Bewusste Verstöße gegen Best-Practices
          <li class="fragment">Zentrales Konzept: <b>Komponenten</b>
        </ul>
      </section>

      <section id="react">
        <h2>React</h2>
        <p>
          <em>ist sehr stabil</em>
        </p>
        <ul>
          <li class="fragment">Semantische Versionierung</li>
          <li class="fragment">API Änderungen meist abwärtskompatibel</li>
          
        </ul>
        <p class="todo">HSV-Trainer-Vergleich</p>
      </section>

      <section>
        <h3>Komponenten in React</h3>
        <img src="images/soc.png">
      </section>

      <section>
        <h3>Komponenten in React</h3>
        <p style="font-size:smaller">Unser Beispiel in Komponenten</p>
        <img src="images/greeting-example-component-hierarchy.png" style="height: 650px">
      </section>


      <section>
        <h3>React Komponenten</h3>
        <ul>
          <li class="fragment">bestehen aus
            <b>Logik und UI</b>
          <li class="fragment">
            <b>keine Templatesprache</b>
          <li class="fragment">werden
            <b>deklarativ</b> beschrieben
          <li class="fragment">werden immer
            <b>komplett gerendert</b> (kein 2-Wege-Data-Binding)
          <li class="fragment">werden zu
            <b>ganzen Anwendungen</b> aggregiert
        </ul>
      </section>

      <section>
        <h3>React Komponenten</h3>
        <ul>
          <li class="fragment">Werden als <b>Funktion mit Hooks</b> oder <b>ES6 Klasse</b> implementiert
            <ul><li>Hooks erst ab React 16.8 (Februar 2019)</li>
              <li>Klassen (noch?) Mainstream</li></ul>
          <li class="fragment">Keine Templatesprache (stattdessen JavaScript)
            <ul><li>Templates können HTML-artige Syntax enthalten (JSX)</ul>
        </ul>
      </section>

      <section>
        <h3>Eine erste Komponente: Hello, World!</h3>
        <p><a target="_blank" href="code/schritte/0-hello_world/public/index.html">Demo</a></p>
        <ul class="fragment">
          <li>Beispiel Schritt-für-Schritt (<code>code/workspace-live-coding</code>)</li>
        </ul>

      </section>

      <section>
        <h3>Hello World React</h3>
        <pre><code data-trim contenteditable>
import React from "react";

export default function HelloMessage(props) {
  const [name, setName] = React.useState(props.initialGreeting || "");

  return (
    &lt;div>
    &lt;input ref={input} onChange={event => setName(event.target.value)} value={name} />

    &lt;p>{name}, World&lt;/p>
    &lt;button onClick={() => setName("")}>Clear&lt;/button>
    &lt;/div>
  );
}
          </code></pre>
      </section>

      <section>
        <h3>Aufruf</h3>
        <div class="fragment">
          <p>
            <code>index.html</code>
          </p>
          <pre><code data-trim contenteditable>
&lt;html>
  &lt;body>
    <div id="mount"></div>
  &lt;/body>
  &lt;script src="dist/main.js">&lt;/script>
&lt;/html>
</code></pre>
        </div>
        <div class="fragment">
          <p>
            <code>main.js</code>
          </p>
          <pre><code data-trim contenteditable class="javascript">
import React from 'react';
import ReactDOM from 'react-dom';

import HelloMessage from './HelloMessage';

const mountNode = document.getElementById('mount');
ReactDOM.render(&lt;HelloMessage initialGreeting="Hello"/>, mountNode);
</code></pre>
        </div>
        <p class="fragment">
          <a target="_blank" href="code/schritte/0-hello_world/public/index.html">Run</a>
        </p>
      </section>

 
      <section data-state="exkurs">
        <h2>ES6: Module, Importe und Exporte</h2>
      </section>
      <section data-state="exkurs">
        <h3>ES6: Ein Default Export pro Modul möglich</h3>
        <pre><code class="javascript" contenteditable>// Person.js
class Person {
  // ...
}
export default Person;
     </code></pre>
        <pre><code class="javascript" contenteditable>// Person.js
  
// in einer Zeile zusammengefasst
export default class Person {
  // ...
}
     </code></pre>
     <pre><code class="javascript"data-trim contenteditable>// createPerson.js
  
// Funktion exportieren
export default function createPerson() { /* ... */ }
        
// oder
function createPerson() { /* ... */ }
export default createPerson;
           </code></pre>
      </section>
      <section data-state="exkurs">
        <h3>ES6: Import</h3>
        <pre><code class="javascript" contenteditable>// Programmer.js
  import Person from './Person';
  
  export default class Programmer extends Person {
    // ...
  }
     </code></pre>
      </section>
      <section data-state="exkurs">
        <h3>ES6: Benannte Exporte</h3>
        <pre><code class="javascript" contenteditable data-trim>// util.js
  export function displayInPage(text) {
      document.body.innerHTML +=
          `${text}<br>` ;
  }
  
  export showInfo = msg => window.alert(`Wichtige Info: ${msg}`);
  
  // or
  function displayInPage(text) { . . . }
  
  const showInfo = ...;
  
  // specify exports
  export { displayInPage, showInfo };
     </code></pre>
        <pre class="fragment"><code class="javascript" contenteditable data-trim>import {displayInPage} from "./util";
  displayInPage('Hello, World');
     </code></pre>
        <!--<pre class="fragment"><code class="javascript" contenteditable data-trim>import {displayInPage as display} from "./util";-->
        <!--display('Hello, World');-->
        <!--</code></pre>-->
        <!--<pre class="fragment"><code class="javascript" contenteditable data-trim>import * as util from "./util";-->
        <!--util.displayInPage('Hello, World');-->
        <!--</code></pre>-->
      </section>
      <section data-state="exkurs">
        <h3>ES6: Arrow Functions</h3>
        <pre><code class="javascript" contenteditable>const displayInPage = (text) => {
   return document.body.innerHTML +=
       `${text}<br>`;
};</code></pre>
        <pre class="fragment"><code class="javascript" contenteditable>// Klammern können weggelassen werden, genau ein Parameter
// ebenso die geschweiften Klassen, wenn nur ein Statement:
const displayInPage = text => document.body.innerHTML += `${text}<br>`;
</code></pre>
      </section>
      <section data-state="exkurs">
        <h3>ES6: Template Strings</h3>
        <p>Template Strings werden in Backticks (``) geschrieben und können Ausdrücke (in
          <code>${}</code>) enthalten:</p>

        <pre><code class="javascript" contenteditable>const name = "Susi";
const greeting = `Hello, ${name}`; // Hello, Susi

const four = `Two and two is: ${2+2}` // Two and two is: 4

const time = `The time is: ${new Date()}`); // The time is: ...
            </code></pre>
      </section>


      <section>
        <h2>Hintergrund</h2>
        <h1>Tool Chain</h1>

        <ul>
          <li>Typisches Tooling im JS/React-Umfeld</li>
          <li>Build-Prozess React-Anwendungen</li>
        </ul>
      </section>

      <section>
        <h2>Die Sprache</h2>
        <p><em><b>ECMAScript 5:</b> Veröffentlicht 2015</em></p>

        <div  class="fragment">
        <ul >
          <li>Unterstützung von praktisch allen Browsern</li>
          <li>Die "Referenz"-Version</li>
          </ul>
          <a href="https://caniuse.com/#search=es5" target="_blank"><img src="images/can-i-use-es5.png" /></a>
         </div>
          <ul class="fragment">
            <li><b>JavaScript</b>: Implementierung</li>
            <li><b>ECMAScript</b>: Spezifikation</li>
            </ul>
      </section>

      <section>

      </section>


      <section>
        <h2>Buildprozess</h2>
        <ul>
          <li>ES6ff- und JSX-Code muss nach ECMAScript 5 übersetzt werden
            <ul>
              <li>Status der ES6 Implementierungen der Browser:
                <a href="https://kangax.github.io/compat-table/es6/" target="blank">
                  https://kangax.github.io/compat-table/es6/
                </a>
              </li>
            </ul>
          <li class="fragment">Typische Werkzeuge
            <ul>
              <li>Babel oder TypeScript (Compiler)
              <li>Webpack (Bundler)
              <li>Webpack Dev Sever (HTTP Server mit Hot Reload)
            </ul>
        </ul>
      </section>
      <section>
        <h2>Webpack und Babel</h2>
        <img src="images/webpack-und-babel.png" style="border:0;box-shadow:0 0 0 0" />
      </section>
      <section>
        <h2>Webpack Development Server</h2>
        <ul>
          <li>Zum Ausführen der Anwendung wird ein Webserver benötigt</li>
          <li class="fragment">Für die Entwicklung
            <b>Webpack Dev Server</b>:
            <ul>
              <li>...führt Webpack auf Basis der Projekt Webpack Konfiguration aus</li>
              <li>...erzeugt Ausgabe in Memory (Performance)</li>
              <li>...Hot Reloading: Automatische Aktualisierung nach Code Änderung</li>
            </ul>
        </ul>
      </section>
      <section>
          <h2>React Devtools</h2>
          <em>React Developer Tools für Chrome und Firefox</em>
          <p>Untersuchen der React Anwendung zur Laufzeit</p>

          <ul>
            <li><a href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=en" target="_blank">Chrome</a></li>
              <li><a href="https://addons.mozilla.org/en-US/firefox/addon/react-devtools/" target="_blank">Firefox</a></li>
            </ul>

            <p><img src="images/screenshot-react-dev-tools.png" /></p>

      </section>  
      <section>
        <h3>Das Beispiel-Projekt</h3>
        <p>Workspace</p>
        <ul>
          <li>
            <code>2019_react_2tage.html</code> Slides im Root-Verzeichnis</li>
          <li>
            <code>code/workspace</code>: Verzeichnis für Eure Übungen</li>
            <li>
              <code>code/material</code>: Code als Ausgangspunkt für Übungen</li>
            <li>
            <code>code/schritte</code>: Fertige Stände nach den einzelnen Teilen</li>
        </ul>
        <p>Starten</p>
        <ol>
          <li>Im
            <b>Root-Verzeichnis (falls noch nicht geschehen)</b>:
            <code>npm start</code>, um den REST-Server zustarten (einmal starten, dann einfach durchlaufen
            lassen)</li>
          <li>In
            <b>code/workspace</b>:
            <code>npm start</code>, um Webpack DevServer zu starten. Kann durchlaufen, aber falls Reloading nicht klappt, neu
            starten</li>
        </ol>
      </section>
      <section>
        <h2>Übung 1: React Hello-World</h2>
        <h3><em>Mach dich mit den Werkzeugen vertraut und schreib deine erste React-Komponente</em></h3>
      </section>
      <section>
        <h3>Schritt #1: Tool-Chain starten (falls noch nicht gemacht)</h3>
        
        <ol style="font-size: 85%">
          <li>
            <code>cd code/workspace</code>
          <li>
            <code>npm start</code>
          <li>Öffne
            <a href="http://localhost:8080" target="_blank">http://localhost:8080</a> im Browser
          <li>Wenn auf der Seite 'Hello, World' steht, ist alles gut
        </ol>
        <img src="images/screenshot-npm-start.png" />
      </section>
      <section>
        <h3>Schritt #2: Deine erste React-Komponente</h3>
        <ul>
          <li>Ersetze die "statische" Komponente (HelloMessage) mit der React-Komponente aus dem vorherigen Beispiel
            aus den
            Folien ("Hello World React")
          <li>
            <em>Zusatzaufgabe: Experimentiere mit der Anwendung, mache einige Änderungen, wie z.B.</em>
            <ul>
              <li>Alle Eingaben sollen in Großbuchstaben auftauchen
              <li>Gib irgendeine Rückmeldung wenn die Eingabe leer ist
            </ul>
          </li>
        </ul>
      </section>

      <section id="t1">
        <h1>Teil I</h1>
        <h2>React-Komponenten (Grundlagen)</h2>
        <a href="code/schritte/1-detail/public/index.html" target="_blank">Ziel-Anwendung</a>
      </section>

      <section>
        <h2>Dokumentation</h2>
        <p>
          <a href="https://reactjs.org/docs/hello-world.html" target="_blank">
            https://reactjs.org/docs/hello-world.html
          </a>
        </p>
      </section>

     
  


      <section>
        <h3>Themen</h3>
        <ul>
          <li>Rendering
          <li>Properties und Zustand
          <li>Referenzen auf DOM-Elemente (Refs)
        </ul>
      </section>
  
      <section>
        <h3>React: Rendering</h3>
        <em>Eigene Komponenten müssen mit einem Großbuchstaben anfangen!</em>
        <ul>
          <li>Komponentenname entspricht dem Klassennamen</li>
          <li>native Komponenten (button, div, input, ...) beginnen mit Kleinbuchstaben</li>
          </ul>
      </section>

      <section>
        <h3>React: Rendering</h3>
        <span class="fragment">
          <p>
            <em>Jede React-Komponente braucht eine
              <code>render</code>-Methode:</em>
            <ul>
              <li>wird aufgerufen beim ersten Rendering und wenn sich der Zustand ändert</li>
              <li>kann HTML-artige JSX-Syntax nutzen</li>
              <li>liefert genau
                <b>ein</b> Element oder
                <b>null</b> oder
                <b>ein Boolean</b> oder
                <b>ein Array</b> oder
               <b>einen String</b> oder
                 <b>ein "Fragment"</b> zurück</li>
            </ul>
            <pre class="fragment"><code class="xml" contenteditable data-trim>
class GreetingDetail extends React.Component {
  render() {
    return (
      <div>
        &lt;input onChange={event => this.updateModel(event.target.value)}
           value={this.state.greeting} />
        <p>{this.state.greeting}, World</p>
      </div>
    );
  }
  // ...
}
</code></pre>
        </span>
      </section>
      <section>
        <h3>React: JSX</h3>
        <ul>
          <li style="font-size: 80%" class="fragment">Wird wie HTML hingeschrieben, inkl Attribute:
            <pre><code class="xml" contenteditable data-trim>
&lt;div>&lt;input type="text"/>&lt;/div>
                    </code></pre>
          </li>
          <li style="font-size: 80%" class="fragment">
            Achtung! <code>class</code>-Attribut heißt
            <code>className</code>:
            <pre><code class="xml" contenteditable data-trim>
                        &lt;h1 className="title">...&lt;/h1>
                    </code></pre>
          </li>
          <li style="font-size: 80%" class="fragment">Attribute, die keine Strings sind, müssen in {} eingeschlossen
            werden:
            <pre><code class="xml" contenteditable data-trim>
&lt;Counter label="Count" count={7} showValues={true} />
                    </code></pre>
          </li>
          <li style="font-size: 80%" class="fragment">Kann pures JavaScript enthalten, eingeschlossen in {}:
            <pre><code class="xml" contenteditable data-trim>
const title = 'Hello, World';
&lt;h1>{title.toUpperCase()}&lt;/h1>
                    </code></pre>
          </li>


          <li style="font-size: 80%" class="fragment">CSS-Eigenschaften werden als Objekt übergeben in
            Camel-Case-Notation:
            <pre><code class="xml" contenteditable data-trim>
const styles = { marginLeft: '10px', border: '1px solid red' };
&lt;h1 style={styles}>...&lt;/h1>
                    </code></pre>
          </li>
        </ul>
      </section>
      <section>
        <h3>React: JSX #2</h3>
        <ul>
          <li style="font-size: 80%" class="fragment">Zuweisen an Variablen
            <pre><code class="xml" contenteditable data-trim>
const counter = &lt;Counter label="..." />
                    </code></pre>
          </li>
          <li style="font-size: 80%" class="fragment">...als Return-Wert:
            <pre><code class="xml" contenteditable data-trim>
function renderCounter(label) { return &lt;Counter label="..." />; }
                      </code></pre>
          </li>
          <li style="font-size: 80%" class="fragment">Fragmente (rendern selber kein Element in den DOM, nur ihre
            Kind-Elemente):
            <pre><code class="xml" contenteditable data-trim>
render() { 
  return &lt;React.Fragment&gt;
    &lt;li>Yes&lt;/li> 
    &lt;li>No&lt;/li>
  &lt/React.Fragment>              
}  
                    </code></pre>
          </li>
          <li style="font-size: 80%" class="fragment">null, false oder boolean, um nichts zu rendern:
            <pre><code class="xml" contenteditable data-trim>
render() {
  if (!someCondition) {
    return null; // oder false oder true
  }

  return ...;
}              
                    </code></pre>
          </li>

        </ul>
      </section>
      <section data-state="exkurs">
        <h3>ES6: Erweiterte Objekt-Literale</h3>
        <pre><code class="javascript" contenteditable>

// ES5:
const firstName = 'Klaus';
const person = {
    firstName: firstName
};
console.log(person.firstName); // Klaus

// ES6:
const firstName = 'Klaus';
const person = {
    firstName
};
console.log(person.firstName); // Klaus
   </code></pre>
      </section>
      <section data-state="exkurs">
        <h3>ES6: Computed Properties</h3>
      <em>Berechnete Keys in Objekten</em>
        <pre><code class="javascript" contenteditable>const schluessel = 'vorname';
const person = {
  [schluessel]: 'Klaus'
};
console.log(person.vorname); // Klaus

let id = 1;
const personen = {
[`id_${id++}`]: 'Klaus',
[`id_${id++}`]: 'Susi'
};
console.log(personen); // Object {id_1: "Klaus", id_2: "Susi"}
</code></pre>
    </section>      
      <section data-state="exkurs">
        <h3>ES6: Destructuring von Objekten</h3>
        <pre><code class="javascript" contenteditable>const person = {
  fistName: 'Klaus',
  lastName: 'Mueller',
  age: 42
};</code></pre>
        <pre class="fragment"><code class="javascript" contenteditable>const {firstName, age, notFound} = person;

console.log(firstName); // Klaus
console.log(age); // 42
console.log(notFound); // undefined
</code></pre>
        <pre class="fragment"><code class="javascript" contenteditable>function someFunction({firstName, age, notFound}) {
  console.log(firstName); // Klaus
  console.log(age); // 42
  console.log(notFound); // undefined
}

someFunction(person);
</code></pre>
      </section>
      <section>
        <h3>React: Properties und Zustand</h3>
        <ul class="fragment">
          <li>
            <b>Properties</b> werden der Komponente von
            <b>außen</b> übergeben (und nicht verändert)</li>
          <li class="fragment">
            <b>Zustand (State)</b> ist eine
            <b>innere</b> Eigenschaft der Komponente (die verändert werden kann)</li>
          <li class="fragment">Beides sind Objekte mit Key-Value-Paaren</li>
        </ul>
      </section>

      <section>
        <h3>Properties einer Komponente</h3>
        <ul class="fragment">
          <li>Properties werden über den Konstruktor in die Komponente hineingereicht</li>
          <li>Properties dürfen nicht verändert werden</li>
          <li>Zugriff über
            <code>this.props</code>
          </li>
        </ul>
        <pre class="fragment"><code class="javascript" contenteditable data-trim>
            class Header extends React.Component {
              constructor(props) {
                super(props);
              }

              render() {
                return (
                  &lt;h1 style={{color: this.props.titleColor}}>{this.props.title}&lt;/h1>
                );
              }
            }
            </code></pre>        
      </section>
      <section>
          <h3>Children einer Komponente</h3>
          <ul class="fragment">
              <li><code>this.props.children</code> enthält Kind-Elemente</li>
          </ul>
          <div class="fragment">Beispiel:
          <pre><code class="javascript" contenteditable data-trim>
  class NavBar extends React.Component {
    render() {
      return (
        &lt;div className="NavBar">
          <h1>{this.props.title}</h1>
         
          {this.props.children}
        &lt;/div>
      );
    }
  }
  </code></pre></div><div class="fragment">Verwendung:
          <pre><code class="javascript" contenteditable data-trim>
    &lt;NavBar title="Navigation">
      &lt;a href="/home">Home&lt;/a&gt;
      &lt;a href="/shop">Shop&lt;/a&gt;
    &lt;/NavBar>
  </code></pre>
</div>
        </section>
      <section>
        <h3>Zustand einer Komponente</h3>
        <ul class="fragment">
          <li>Beispiel: Inhalt eines Eingabefelds, Daten vom Server, Menu offen oder zu</li>
          <li>
            <b>Werte</b> üblicherweise immutable</li>
          <li class="fragment">
            <b>Initialisieren</b> im Konstruktor mit
            <code>this.state={}</code>
          <li class="fragment">Zustand
            <b>lesen</b> über
            <code>this.state</code>
          <li class="fragment">Zustand
            <b>setzen</b> über
            <code>this.setState()</code>
            <ul class="fragment">
              <li>
                <b>Achtung:</b> kein "reiner" Setter</li>
              <li class="fragment">Führt alten und neuen Zustand zusammen</li>
              <li class="fragment">Wird asynchron ausgeführt!</li>
              <li class="fragment">
                <b>Löst erneutes rendern der
                  <i>gesamten</i> Komponente aus</b>
              </li>
            </ul>
          <li class="fragment">Eines der <b>zentralen</b> Konzepte von React</li>
        </ul>
      </section>

      <section>
          <h3 class="todo">useState Gotchas</h3>
          <ul>
            <li>Asynchroner Zugriff</li>
            <li>Updater Funktion</li>
            </ul>
        </section>

      <section>
        <h3>Beispiel: Zustand einer Komponente</h3>
        <pre><code class="javascript" contenteditable data-trim>
function GreetingDetail extends React.Component {
    constructor(props) {
        super(props);
        this.state = { name: 'Klaus' };
    }

    updateModel(event) {
        // Zustand ändern: Komponente wird neu gerendert
        this.setState({name: event.target.value});
    }

    render() {
        return &lt;input value={this.state.name}
            onChange={e => this.updateModel(e)} />
    }
   // ...
}
</code></pre>
      </section>
      <section>
        <h3>React: Events und Data Binding</h3>
        <p>
          <em>Es gibt keine automatische Bindung an Modelle (2-Wege Databinding)</em>
        </p>
        <ul class="fragment">
          <li>DOM-Events werden in React-Events verpackt
          <li>React-Events haben weitgehend selbe API wie DOM-Events
          <li>Besonderes Event:
            <b>onChange</b>
            <ul>
              <li>onChange ist auf
                <code>input</code>,
                <code>textarea</code>,
                <code>select</code> definiert und verhält sich Komponenten- und Browser-übergreifend einheitlich
              </li>
            </ul>
          </li>
        </ul>
        <pre class="fragment"><code class="xml" contenteditable data-trim>
class GreetingDetail extends React.Component {
  render() {
    return (
        &lt;input onChange={event => . . .} />
    );
  }
  // ...
}
</code></pre>
      </section>

      <section>
        <h3>Render Zyklus</h3>
        <img src="images/event-zustand-render.png" height="550" style="border:0;box-shadow:0 0 0 0">
      </section>

      <section>
        <h3>Virtual DOM</h3>
        <p>"Rendern" hat leider doppelte Bedeutung!</p>
        <img src="images/virtual-dom.png" style="height:650px">
      </section>
      <section>
          <h3>React: Referenzen auf nativen DOM</h3>
          <ul class="fragment">
            <li><code>React.createRef() </code> erzeugt ein allgemeines Referenz-Objekt</li>
            <li>Das Objekt wird in der Komponente gespeichert (i.d.R. als Instanz-Variable)</li>
            <li>Eine Komponente wird der Referenz zugewiesen</li>
            <li>Über <code>current</code>-Property am Referenz-Objekt erhält man Zugriff auf das native DOM-Element</li>
          </ul>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
  class HelloMessage extends React.Component {
    constructor(props) { 
      super(props);
      this.inputRef = React.createRef();
    }
    render() {
      return <div>
          &lt;input ref={this.inputRef} 
                    onChange={...} value={...}/>
          &lt;button onClick={() => this.reset()}>Clear&lt;/button>
        </div>;
    }
  
    reset() {
      this.setState({greeting: ""});
  
      // focus() ist Funktion auf nativem DOM Element
      this.inputRef.current.focus();
    }
  }
  </code></pre>
        </section>
      <section>
        <h3>React: Referenzen auf nativen DOM</h3>
        <ul class="fragment">
          <li>Alternativ: Elementen kann eine Callback-Funktion
            <code>refs</code> übergeben werden
          <li class="fragment">Funktion wird nach dem Rendern mit Referenz auf DOM Element aufgerufen (oder
            <code>null</code>)
          <li class="fragment">Diese Referenz kann man z.B. als Member-Variable speichern
        </ul>
        <pre class="fragment"><code class="javascript" contenteditable data-trim>
class HelloMessage extends React.Component {
  render() {
    return (
      <div>
        &lt;input ref={inputElement => this.inputElement = inputElement} 
                  onChange={...} value={...}
        />
        &lt;button
          onClick={() => this.reset()}>
            Clear
        &lt;/button>
      </div>
    );
  }

  reset() {
    this.setState({greeting: ""});

    // focus() ist Funktion auf nativem DOM Element
    this.inputElement.focus();
  }
}
</code></pre>
      </section>

      <section>
        <h3>Properties, State und Instanz-Variablen</h3>
        <ul>
          <li class="fragment">
            <b>Properties</b>: Konfiguration von außen übergeben. Unveränderlich innerhalb der Komponente</li>
          <li class="fragment">
            <b>State:
            </b> Interner und veränderlicher Zustand der Komponente. State-Änderung führt zu re-rendering
          </li>
          <li class="fragment">
            <b>Instanz-Variablen</b>: Nicht render-relevante Informationen, zB Referenzen auf DOM-Elemente, Callbacks
            zum Beenden
            von Timern</li>
        </ul>
      </section>

      <section>
        <h2>Übung 2: Detail-Ansicht für unsere Gruß-Anwendung</h2>
        <h3>Erzeuge eine Komponente mit der man einen Namen und eine Grußformel eingeben kann</h3>
      </section>
      <section>
        <h3>Schritte</h3>
        <h4>Erweitere deine erste React-Komponente im workspace-Ordner</h4>
        <ol>
          <li>benenne deine HelloMessage-Komponente (und das HelloMessage-Modul) in
            <code>GreetingDetail</code> um
          <li>du brauchst zwei Eingabefelder, die
            <code>name</code> und
            <code>greeting</code> im Zustand der Komponente setzen
          <li>Erweitere deine Komponente so, dass man von außen Properties übergeben kann, die den Zustand
            initialisieren</li>
          <li>Füge einen "Clear"-Button hinzu, der den Inhalt beider Eingabefelder löscht. Das entsprechende
            Event auf dem Button heißt <code>onClick</code></li>
        </ol>
        <img src="images/screenshot-name-greeting.png" />
      </section>

      <section id="t2">
        <h1>Teil II</h1>
        <h2>React-Komponenten: Details, Hierarchien und Anwendungen</h2>
        <a href="code/schritte/2-hierarchy/public/index.html" target="_blank">Ziel-Anwendung</a>
      </section>

      <section>
        <h3>Themen</h3>
        <ul>
          <li>Komponenten als Klassen</li>
          <li>Darstellung von Listen</li>
          <li>Architektur-Idee: Controller-Komponente und View-Komponente</li>
          <li>Durchreichen von Zustand und Callbacks</li>
        </ul>
      </section>


      <section>
        <h3 class="todo">Komponenten als Klassen</h3>
        <ul class="fragment">
          <li>Alternative zu Klassen</li>
          <li>Komponente ist eine einfache Funktion</li>
          <li>entspricht der
            <code>render</code>-Methode einer
            <code>React.Component</code>
          <li>Properties werden per Parameter übergeben (als Objekt)</li>
          <li>Zurzeit nur ohne Zustand und ohne Lifecycle-Methoden</li>
        </ul>
        <pre class="fragment"><code class="javascript" contenteditable data-trim>
import React from 'react';

export default function Greet(props) {
  return (
      <div>
          <h1>{props.greeting}</h1>
          <h2>{props.name}</h2>
      </div>
  );
}

// Verwendung:
&lt;Greet name="Susi" greeting="Hello" /&gt;

</code></pre>
      </section>

      <section data-state="exkurs">
        <h3>Hintergrund</h3>
        <h2>ES6 Features</h2>
      </section>

      <section data-state="exkurs">
        <h3>ES6: Klassen</h3>
        <pre><code class="javascript" contenteditable>class Person {
    constructor(name) {
        this._name = name;
    }
    getName() {
        return this._name;
    }
}
class Programmer extends Person {
    constructor(name, language) {
        super(name);
        this.language = language;
    }
    code() {
        return `${this.getName()} codes in ${this.language}`;
    }
}</code></pre>
        <pre class="fragment"><code class="javascript" contenteditable>const programmer = new Programmer('Erna', 'JavaScript');
console.log(programmer.code());
console.log(programmer instanceof Programmer); // true
console.log(programmer instanceof Person); // true</code></pre>
      </section>

      <section>
        <div style="display: flex">
          <div style="flex: 1">
            <img src="images/greeting-master-table.png" style="max-width:100%" />
          </div>
          <div style="flex: 1">
            <h3>Listen</h3>
            <div class="fragment" style="display: flex; flex-direction: column; justify-content: center;align-items: center">
              <p>JSX bietet nichts für Listen</p>
              <p>Ausgabe typischerweise über
                <code>Array.map()</code>
              </p>
              <p>Elemente einer Liste brauchen einen eindeutigen Key</p>


              <pre class="fragment"><code class="javascript" contenteditable data-trim>
const greetings = [
  { id: 0, name: 'Olli', greeting: 'Huhu' },
  { id: 1, name: 'Oma', greeting: 'Hallo' }
];

const MyTable(props) => (
    &lt;table>
      {props.greetings.map(greeting =>
        &lt;tr key={greeting.id}>
            &lt;td>{greeting.name}&lt;/td>
            &lt;td>{greeting.greeting}&lt;/td>
        &lt;/tr>
      )}
    &lt;/table>
);
</code></pre>
            </div>
          </div>
        </div>
      </section>
      <section>
        <h3>Listen und Keys</h3>
        <ul class="fragment">
          <li>Arrays können in
            <code>render</code> zurückgegeben werden (anstatt
            <b>eines</b> Root Elements)
          <li>Elemente brauchen trotzdem einen eindeutigen Key
        </ul>
        <pre class="fragment"><code class="javascript" contenteditable data-trim>
// Beispiel: statische Elemente          
function Choices(props) { 
  return [
    &lt;td key="yes">Yes&lt;/td>,
    &lt;td key="no">No&lt;/td>
  ]
}
          </code></pre>

        <pre class="fragment"><code class="javascript" contenteditable data-trim>
// Beispiel: dynamisches Array          
function GreetingRows(props) {

  // map liefert ein Array zurück!
  return props.greetings.map(greeting =>
    &lt;tr key={greeting.id}>
      &lt;td>{greeting.name}&lt;/td>
      &lt;td>{greeting.greeting}&lt;/td>
    &lt;/tr>
  ;
)
</code></pre>
      </section>
      <section>
        <h3>Fragmente</h3>
        <ul style="font-size:90%">
          <li class="fragment">Eine React-Komponente liefert immer genau
            <b>ein</b> (Top-Level)-Element zurück</li>
          <li class="fragment">Ein Fragment ist ein Top-Level-Element, für das kein DOM-Element erzeugt wird</li>
        </ul>
        <pre class="fragment"><code class="javascript" contenteditable data-trim style="font-size:70%">
// geht nicht:          
function Choices(props) { 
  &lt;td key="yes">Yes&lt;/td>
  &lt;td key="no">No&lt;/td>
}  

// geht:          
function Choices(props) { 
  return &lt;React.Fragment>
    &lt;td key="yes">Yes&lt;/td>
    &lt;td key="no">No&lt;/td>
  &lt;/React.Fragment>  
}
            </code></pre>
      </section>
      <section>
        <h3>Teil II (b)</h3>
        <h2>Anwendungen und Komponentenhierarchien</h2>
      </section>
      <section>
        <h3>Problem: Kommunikation zwischen Komponenten</h3>
        <p>#1: Welche Komponente soll angezeigt werden (Master oder Detail?)</p>
        <img src="images/component-hierarchy-problems-01-views.png" style="height:550px" />
      </section>
      <section>
        <h3>Problem: Kommunikation zwischen Komponenten</h3>
        <p>#2: Wo wird der State (Greetings) verwaltet?</p>
        <img src="images/component-hierarchy-problems-02-greeting.png" style="height:550px" />
      </section>
      <section>
        <h3>Problem #1</h3>
        <h2>Welche Komponente soll angezeigt werden?</h2>
        <p>Master oder Detail?</p>
        <p>Schritt-für-Schritt in <code>code/workspace-live-coding</code></p>
      </section>
      <section>
        <h3>Controller Komponente #1</h3>
        <p>Verwaltet den Zustand (u.a. welche Komponente sichtbar ist)</p>
        <img src="images/greeting-hierarchy-mode.png" style="height:550px" />
      </section>
      <section>
        <h3>Controller Komponente #2</h3>
        <p>Rendering der Children</p>
        <pre><code class="javascript" contenteditable data-trim>
class GreetingController extends React.Component {
  constructor() {
    this.state = { mode: 'MASTER' }
  }

  render() {
    if (this.state.mode === 'MASTER') {
      return &lt;GreetingMaster />;
    } 
    return &lt;GreetingDetail />;
  }
}            
            </code></pre>
      </section>

      <section>
        <h3>Controller Komponente</h3>
        <p class="fragment">Wie wird zwischen den Komponenten kommuniziert?</p>
        <p class="fragment">Beispiel: Child-Komponente will Parent Informationen übermitteln</p>
        <p class="fragment">Callback-Funktionen als Properties #1</p>
        <img class="fragment" src="images/greeting-hierarchy-mode-callback.png" style="height:550px" />
      </section>

      <section>
        <h3>Controller Komponente</h3>
        <p>Kommunikation mit Children: Callback-Funktionen als Properties #2</p>
        <pre><code class="javascript" contenteditable data-trim>
  class GreetingController extends React.Component {
    constructor() { . . . }
  
    render() {
      if (this.state.mode === 'MASTER') {
        return &lt;GreetingMaster 
          onAdd={() => this.setState({mode: 'DETAIL'}) } />;
      } 
      return &lt;GreetingDetail 
          onSave={() => this.setState({mode: 'MASTER'}) } />;
    }
  }      
</code></pre>
        <pre class="fragment"><code class="javascript" contenteditable data-trim>
  class GreetingMaster extends React.Component {
    render() {
      return (
        ...
        &lt;button onClick={this.props.onAdd}>Add&lt;/button>
      )
    }
  }            
              </code></pre>
      </section>

      <section>
        <h3>Problem #2</h3>
        <h2>Wo wird der State (Greetings) verwaltet?</h2>
        <p>Wie kommen neue Greetings (GreetingDetail) in die Liste (GreetingMaster)?</p>
      </section>
      <section>
        <h3>Controller Komponente</h3>
        <p class="fragment">Verwaltet den "globalen" State</p>
        <p class="fragment">State wird als Property an Children übergeben</p>
        <img class="fragment" src="images/greeting-hierarchy-greetings.png" style="height:550px" />
      </section>
      <section>
        <h3>Controller Komponente</h3>
        <p>State wird als Property an Children übergeben #2</p>
        <pre><code class="javascript" contenteditable data-trim>
class GreetingController extends React.Component {
  constructor() { 
    this.state = {
      mode: 'MASTER',
      greetings: . . .
    }        
  }  
    
  render() {
    if (this.state.mode === 'MASTER') {
      return &lt;GreetingMaster
        greetings={this.state.greetings} 
        onAdd={() => this.setState({mode: 'DETAIL'}) } 
      />;
    }
    . . . 
  }
}      
  </code></pre>
        <pre class="fragment"><code class="javascript" contenteditable data-trim>
class GreetingMaster extends React.Component {
  render() {
    const greetings = this.props.greetings;
    return (
      &lt;table>
        { greetings.map(g => &lt;tr>...&lt;/tr>) }
      &lt;/table>
      &lt;button onClick={this.props.onAdd}>Add&lt;/button>
    )
  }
}            
                </code></pre>
      </section>
      <section>
        <h3>Controller Komponente</h3>
        <p class="fragment">Verwaltet den "globalen" State</p>
        <div class="fragment">
          <img src="images/greeting-hierarchy-onsave.png" style="height:550px" />
          <p><span style="color: #9D4493">Neues Greeting</span> wird per Callback-Funktion zurück gegeben</p>
        </div>
      </section>
      <section>
        <h3>Controller Komponente</h3>
        <p>Neues Greeting wird per Callback-Funktion übergeben #2</p>
        <pre><code class="javascript" contenteditable data-trim>
  class GreetingController extends React.Component {
    constructor() { . . . }
      
    render() {
      if (this.state.mode === 'MASTER') {
        . . .
      }
      return &lt;GreetingDetail 
        onSave={(newGreeting) => this.setState({
          greetings: [...this.state.greetings, newGreeting],
          mode: 'MASTER'}) 
        } 
      />;
    }
  }      
    </code></pre>
        <pre class="fragment"><code class="javascript" contenteditable data-trim>
  class GreetingDetail extends React.Component {
    render() {
      return (
        &lt;input name="name" . . . />
        &lt;input name="greeting" . . . />
        &lt;button onClick={() => this.props.onSave({
          name: this.state.name,
          greeting: this.state.greeting
          })
          }>Add&lt;/button>
      )
    }
  }            
                  </code></pre>
      </section>



      <section>
        <h3>Komponenten in Hierarchien</h3>
        <p>Beispiel: Unsere Anwendung (Zusammenfassung)</p>
        <img src="images/greeting-hierarchy.png" style="height:550px" />
      </section>

      <section>
        <h3>Smart und Dumb Components</h3>
        <p style="font-size: smaller;margin-bottom:0">(Alternativ: Container und Presentation Components)</p>
        <!--<img src="smart-dumb.jpg">-->
        <!--<img src="smart-dumb.png">-->
        <img style="margin-top:0;max-height:600px" src="images/component-communication.png">
      </section>

      <section>
        <h2>Übung 3: Eine komplette Anwendung zusammen setzen</h2>
        <h3>Füge deinen bestehenden Detail-View (
          <code>GreetingDetail</code>) und einen Master-View über eine Controller-Komponente zusammen</h3>
      </section>
      <section>
        <h3>Schritte</h3>
        <ol>
          <li>kopiere das Material aus
            <code>code/material/2-hierarchy</code> in deinen src-Ordner
            <span style="font-size:85%">(oder dein fertiges
              <code>GreetingDetail</code> verwenden)</span>

          <li>erweitere im
            <code>GreetingController</code> die render-Methode, so dass dein
            <code>GreetingDetail</code> angezeigt wird, wenn der Benutzer den Add-Button klickt:
            <ul>
              <li>dort gibt es bereits einen Kommentar, der dir die richtige Stelle anzeigt und weitere Details enthält
              <li>übergib einen Callback der
                <code>addGreeting</code> nutzt
            </ul>
          <li>im deinem
            <code>GreetingDetail</code> brauchst du einen neuen Knopf, der mit dem neuen Gruß den Callback aufruft
          </li>
          <li  style="font-size:75%">
            <b>Optional:</b> Füge dem GreetingDetail einen <b>neuen</b> Knopf "Abbrechen" hinzu,
            mit dem nur der Master wieder angezeigt wird (der eingegebene Gruße wird nicht gespeichert)  
            </li>
           
        </ol>
      </section>
      <section>
        <h3>GreetingMaster</h3>
        <img src="images/greeting-master.png" style="border:0;box-shadow:0 0 0 0" />
      </section>
      <section>
        <h3>GreetingDetail</h3>
        <img src="images/greeting-detail.png" style="border:0;box-shadow:0 0 0 0" />
      </section>

      <section id="t3">
        <h1>Teil III</h1>
        <h2>Daten lesen und schreiben vom Server</h2>
        <a href="code/schritte/3-remote/public/index.html" target="_blank">Ziel-Anwendung</a>
      </section>

      <section>
        <h3>Herausforderungen</h3>
        <ol>
          <li>Wie machen wir das Laden und Speichern technisch?
          <li>Wo steht der Code zum initialen Laden der Grüße? (beim Start der Anwendung)
          <li>Wo speichern wir?
          <li>Wie funktioniert asynchrone Verarbeitung in React?
        </ol>
      </section>

      <section>
        <h3>Server-Calls</h3>
        <ul>
          <li>React macht keine Angabe, wie Server-Calls (technisch) gemacht werden</li>
          <li>Häufig in React verwendet:
            <b>fetch</b> API
            <ul>
              <li>Browser-API zum Ausführen von HTTP Requests</li>
              <li>
                <a href="http://caniuse.com/#search=fetch" target="_blank">hohe Verbreitung</a>
              </li>
              <li>Spezifikation:
                <a href="https://fetch.spec.whatwg.org/" target="_blank">https://fetch.spec.whatwg.org/</a>
              </li>
              <li>Polyfill:
                <a href="https://github.com/github/fetch" target="_blank">https://github.com/github/fetch</a>
              </li>
            </ul>
        </ul>
      </section>
      <section>
        <h3>Beispiel: fetch</h3>
        <p>Daten lesen per GET</p>
        <pre><code class="javascript" contenteditable data-trim>
          // Für GET Zugriff reicht es, die URL anzugeben:
          try {
            const response = await fetch('http://localhost:7000/api/greetings')
            const json = await response.json();
            // ...
          } (catch ex) {
            console.error('request failed', ex)
          }
          </code></pre>        
        <pre class="fragment"><code class="javascript" contenteditable data-trim>
// Alternative mit Promise:

fetch('http://localhost:7000/api/greetings')
  .then(response => response.json())
  .then(json => /* ... */)
  .catch(ex => console.error('request failed', ex));
</code></pre>

      </section>
      <section>
        <h3>Beispiel #2: fetch</h3>
        <p>Daten lesen per POST</p>
        <div class="fragment">
          <p>
            <code>fetch</code> erwartet als zweiten Parameter ein Objekt mit Konfigurationsparametern, u.a:
            <ul>
              <li>
                <code>method</code>: gibt die HTTP Methode an (
                <code>PUT</code>,
                <code>POST</code>,
                <code>DELETE</code>, ...)</li>
              <li>
                <code>headers</code>: Objekt mit HTTP Headern für den Request</li>
              <li>
                <code>body</code>: Der Request-Payload (als String)</li>
            </ul>
        </div>
        <pre class="fragment"><code class="javascript" contenteditable data-trim>
const response = await fetch(url, {
  method: 'POST',
  headers: {
    'Accept': 'application/json',
    'Content-Type': 'application/json'
  },
  body: JSON.stringify(payload)
})
// ... 
    </code></pre>
      </section>


      <section data-state="exkurs">
        <h2>ES6: Promises</h2>
      </section>
      <section data-state="exkurs">
        <h3>Ein Promise ist ein Versprechen auf einen Wert</h3>
        <h4 class="fragment">Wird evtl. erst in der Zukunft eingelöst</h4>
      </section>

      <section data-state="exkurs">
        <h3>Verkettete Ausführung</h3>
        <pre><code class="javascript" contenteditable>const promise = . . .;
</code></pre>
        <pre class="fragment"><code class="javascript" contenteditable>// then returns a new promise
const promise2 = promise.then(value => `${value} plus stuff`);</code></pre>
        <pre class="fragment"><code class="javascript" contenteditable>promise2.then(value => console.log(value));
// Output after 1 second: Result from promise plus stuff
</code></pre>
      </section>
      <section data-state="exkurs">
        <h3>Fehler führen zum Abbruch der Chain</h3>
        <h4>Allerdings
          <b>muss</b> man etwas tun, um das mitzubekommen: catch()</h4>
      </section>

      <section data-state="exkurs">
        <h3>Catch-Klausel im Erfolgsfall</h3>
        <pre><code class="javascript" contenteditable>Promise
    // creates and directly resolves promise
    .resolve('Result from promise')
    .then(x => {
        // this will be printed
        console.log(x);
    })
    .then(() => {
        console.log('This will be printed');
    })
    // this will NOT be printed as no error occured
    .catch(e => console.log('error: ', e))

// Output:
// Result from promise
// This will be printed</code></pre>
      </section>
      <section data-state="exkurs">
        <h3>Catch-Klausel im Fehlerfall</h3>
        <pre><code class="javascript" contenteditable>Promise
    // creates and directly resolves promise
    .resolve('Result from promise')
    .then(x => {
        // this will be printed
        console.log(x);
        throw new Error('Something went wrong');
    })
    .then(() => {
        console.log('This will NOT be printed');
    })
    // this will be printed
    .catch(e => console.log('error: ', e))

// Output:
// Result from promise
// error:  [Error: Something went wrong]</code></pre>
      </section>

      <section>
        <h3>fetch im Detail</h3>

        <pre><code class="javascript" contenteditable data-trim>
try {
  // 1. fetch returns a promise, that will be resolved
  // with a Response object when response is received
  // from server
  const response = await fetch('http://localhost:7000/api/greetings');

  // 2. the Response object contains a json() function,
  // that returns the parsed JSON from the Response body
  const json = await response.json();

  // 3. with the resolved JSON object we set the
  // component state (=&gt; leads to re-rendering)
  this.setState({greetings: json});
} catch (ex) {
  // 4. in case something goes wrong (during request,
  // request processing or rendering)
  console.error('request failed', ex);
  // as an alternative we could set and render an error msg:
  this.setState({error: ex})
}

</code></pre>
        <p>
          <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch API Doku</a>
        </p>
      </section>
     

      <section data-state="exkurs">
        <h3>Alternative zu Promises</h3>
        <h2>async / await</h2>
        <p>Erlauben es, asynchronen Code "linear" hinzuschreiben</p>
        <ul class="fragment">
          <li>Seit ECMASCript 2017 Standard</li>
          <li>Babel und TypeScript können nach ES5 compilieren</li>
          <li>Promise Polyfill für ältere Browser verwenden</li>
        </ul>
      </section>

      <section data-state="exkurs">
        <h3>async / await</h3>
        <ul>
          <li class="fragment">
            <code>async</code> definiert "async functions"</li>
          <li class="fragment">
            <code>async</code> functions liefern&nbsp;
            <b>immer</b> ein Promise zurück:
            <pre><code class="javascript" contenteditable data-trim>
async function greet(name) {
  return `Hello, ${name}`;
}

const greeting = greet('Klaus');

// greeting ist ein Promise!
console.log(greeting instanceof Promise); // => true
console.log(greeting) // => Promise {&lt;resolved>: "Hello, Klaus"}
                </code></pre>
          </li>
          <li class="fragment">
            <code>aync</code> function als Fat Arrow function:
            <pre><code class="javascript" contenteditable data-trim>
const greet = async (name) => `Hello, ${name}`;                
  
const greeting = greet('Klaus');
  
// greeting ist ein Promise!
console.log(greeting instanceof Promise); // => true
console.log(greeting) // => Promise {&lt;resolved>: "Hello, Klaus"}
                  </code></pre>
          </li>
          <li class="fragment">
            Nur in
            <b>async functions</b> kann
            <code>await</code> verwendet werden!</li>
        </ul>
      </section>

      <section data-state="exkurs">
        <h3>async / await</h3>
        <p>
          <code>await</code> wartet auf erfüllte Promises</p>
        <pre class="fragment"><code class="javascript" contenteditable data-trim>
async function greet(name) {
  return `Hello, ${name}`;
}

// oder:
function greet(name) { return new Promise(...); }

async function sayWhat(name) {
  const greeting = await greet(name);

  // ...Achtung! Hier zwischen kann Zeit vergehen...

  // greeting ist ein String!
  console.log(greeting); // => Hello, ...
}
                  </code></pre>
      </section>
      <section data-state="exkurs">
        <h3>async / await</h3>
        <p>Statt
          <code>then</code> bzw
          <code>catch</code> werden mehrere
          <code>await</code> Statements bzw Exception Handling verwendet:</p>
        <pre class="fragment"><code class="javascript" contenteditable data-trim>
// Liefert ein Promise zurück
async function loadUser(username) { . . . };
async function loadProfileDate(userId) { . . .};

async function loadData() {
  try {
    const user = await loadUser('klaus');
    const profile = await loadProfileData(user.userId);
  } catch (e) {
    console.error("Something failed")
  }
}
                    </code></pre>
      </section>
    
      <section>
        <h3>Wann werden Daten gelesen und geschrieben?</h3>
      </section>
      <section>
        <h3>Initiales Laden von Daten</h3>
        <p style="font-size:80%">Komponenten können optionale
          <a href="https://reactjs.org/docs/react-component.html#the-component-lifecycle" target="_blank">Lifecycle-Methoden</a>
          haben</p>
        <img style="max-height: 500px;margin:0" src="images/react-lifecycle-1.png" />
        <p><a href="code/schritte/2c-hierarchy-comp-lifecycle/public/index.html" target="_blank">Beispiel-Anwendung</a></p>
      </section>
      <section>
        <h3>Initiales Laden von Daten</h3>
        <div class="fragment">
          <p>
            <code>componentDidMount</code> wird aufgerufen, wenn Komponente ins DOM gerendert wurde</p>
          <p>Hier werden Daten üblicherweise initial geladen:</p>
          <pre><code class="javascript" contenteditable data-trim>class GreetingController extends React.Component {
  constructor(props) {
    // intial state (empty now)
    this.state = { greetings: [] };
  }

  // 'async' wegen 'await' notwendig (sonst ohne 'async' hinschreiben)
  async componentDidMount() {
    try {
      const response = await fetch('/api/greetings');
      const json = await response.json();
      this.setState({ greetings: json});
    } catch (error) { . . .}
  }
}
                </code></pre>
          <p class="fragment">
            <em>Empfehlung:</em> Zugriffe auf Server in externes Modul auslagern (besser test- bzw mockbar)</p>
        </div>
      </section>
      <section>
          <h3>Laden von Daten mit Props</h3>
          <p  class="fragment">Aufgabe: Daten sollen abhängig von Properties geladen werden</p>
          <p  class="fragment">Beispiel: einzelnes Greeting per greetingId)</p>
          
          <p  class="fragment">Problem: wir müssen auf Veränderung der Properties reagieren</p>
          <img  class="fragment" style="max-height: 500px;margin:0" src="images/react-lifecycle-2.png" />
        </section>
  
      <section>
        <h3>Laden von Daten mit Props</h3>
        <div class="fragment">
          <p>
            <code>componentDidMount</code> und <code>componentDidUpdate</code> müssen implementiert werden</p>
          <pre><code class="javascript" contenteditable data-trim>class GreetingController extends React.Component {
  constructor(props) { . . . }

  async componentDidMount() {
      const response = await fetch(`/api/greetings/${this.props.greetingId}`);
      . . .
  }

  async componentDidUpdate(prevProps) {
    if (prevProps.greetingId !== this.props.greetingId) {
        const response = await fetch(`/api/greetings/${this.props.greetingId}`);
        ...
    }
  }
}
                </code></pre>
        </div>
      </section>      
      <section>
        <h3>Speichern von Daten</h3>
        <p>Zum Beispiel als Folge einer Benutzerinteraktion:</p>
        <pre class="fragment"><code class="javascript" contenteditable data-trim>class GreetingController extends React.Component {
  render() {
    ...
      &lt;GreetingDetail onSave={greeting => this.saveGreeting(greeting)} />
    ...
  }
  async saveGreeting(greetingToBeSaved) {
    try {
      const response = await fetch('/api/greetings', {
        method: 'POST',
        headers: ...,
        body: JSON.stringify(greetingToBeSaved)
      });
      const newGreeting = response.json();

      // Neuen Gruss an bestehende Liste anfuegen und State neu setzen
      const newGreetings = [ ...this.state.greetings, newGreeting ];
      this.setState({greetings: newGreetings});
    } catch (err) { . . . }
  }
}
                </code></pre>
      </section>

      <section>
        <h2>Übung: Laden und Speichern der Daten von/auf einem Server</h2>
        <p>
          <em>Entwickle auf Basis von fetch eine Version des GreetingControllers, der die Daten auf dem Server laden
            und dort
            wieder speichern kann</em>
        </p>
        <p>Der Server ist bereits vorgegeben und kann mit
          <code>npm run start-backend</code> im Root-Verzeichnis gestartet werden. Er ist dann unter Port 7000
          erreichbar</p>
      </section>
      <section>
        <h3>Schritte</h3>
        <ol>
          <li>Kopiere
            <code>code/material/3-remote/GreetingController.js</code> in deinen Arbeitsbereich
          <li>Die Serverzugriffe sollen in
            <code>loadGreetings</code> und
            <code>saveGreeting</code> erfolgen</li>
          <li>Dort sind bereits entsprechende TODOs für dich eingetragen</li>
          <li>Die URL des Backends steht in der Konstante <code>BACKEND_URL</code>.
          </li>
        </ol>
      </section>


 
      <section id="t-test">
          <h1>Teil IV</h1>
          <h2>Testen von React Anwendungen</h2>
          <ul style="font-size:85%">
            <li>
              <a href="code/schritte/4-test/public/index.html" target="_blank">Ziel-Anwendung</a>
            </li>
            <li>
              <a href="code/schritte/4-test/test-report.html" target="_blank">Test Report</a>
            <li>
              <a href="code/schritte/4-test/coverage/lcov-report/index.html" target="_blank">Coverage Report</a>
            </li>
          </ul>
        </section>
  
        <section data-transition="slide none">
          <h2>Was testen wir überhaupt?</h2>
          <ul>
            <li class="fragment">
              <b>UI-unabhängige Logik</b> (z.B. Services, Backend-Calls)</li>
            <li class="fragment">
              <b>Rendern</b> (wird meine Greeting-Liste für ein Satz von Greetings korrekt dargestellt)</li>
            <li class="fragment">
              <b>Interaktionen</b> (funktionieren meine Event-Listener korrekt)</li>
            <li class="fragment">
              <b>Verhalten im Browser</b> (z.B. korrekte Darstellung, Browser-spezifisches JavaScript, Arbeiten mit
              history, Titelzeile,
              Scrollbars etc)</li>
          </ul>
        </section>
  
        <section data-transition="slide none">
          <h2>Was testen wir überhaupt?</h2>
          <ul>
            <li style="color: lightgrey">
              <b>UI-unabhängige Logik</b>
            </li>
            <li>
              <b>Rendern</b> (wird meine Greeting-Liste für ein Satz von Greetings korrekt dargestellt)
            </li>
            <li>
              <b>Interaktionen</b> (funktionieren meine Event-Listener korrekt)
            </li>
            <li style="color: lightgrey">
              <b>Verhalten im Browser</b> (z.B. korrekte Darstellung, Browser-spezifisches JavaScript, Arbeiten mit
              history, Titelzeile,
              Scrollbars etc)</li>
          </ul>
        </section>
  
        <section>
          <h2>Anforderungen</h2>
          <ul>
            <li class="fragment">Komponenten müssen im Test gerendert werden können</li>
            <div class="fragment">
            <li>Gerenderte Komponenten/HTML-Elemente müssen gefunden und validiert werden</li>
            <li>
              <ul>
                <li>Beispiel: CSS-Klasse korrekt gesetzt, 'value' korrekt gesetzt</li>
              </ul>
            </li>
              
          </div>
            <div class="fragment">
            <li>Interaktion mit DOM muss möglich sein
              <ul>
            <li>Events müssen getriggert oder simuliert werden können</ul></li>
          </div>
          </ul>
        </section>
  
        <section>
          <h1>Jest</h1>
          <p>
            <em>"Delightful JavaScript Testing" (
              <a href="http://facebook.github.io/jest/" target="_blank">http://facebook.github.io/jest/</a>)</em>
          </p>
          <p class="fragment">Vollständige Test-Lösung, wird von Facebook für Testen von React verwendet:</p>
          <ul class="fragment">
            <li>Test Runner</li>
            <li>Specs, Assertions, Mocks</li>
            <li>Code Coverage</li>
            <li>"Snapshot testing"</li>
          </ul>
        </section>
        <section>
          <h3>Beispiel: Ein einfacher Test</h3>
          <pre><code class="javascript" contenteditable data-trim>// sum.js (oder sum.ts)
  export const sum = (a,b) => a+b;
  </code></pre>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>// sum.test.js
  import {sum} from '../sum.js';
  
  test('sum of 2 and 2 is 4', () => {
    expect(sum(2, 2)).toBe(4);
  });
  
  test('sum of 2 and 2 is not 3', () => {
    expect(sum(2, 2)).not.toBe(3);
  });
          </code></pre>
        </section>
        <section>
          <h2>Testcases</h2>
          <p>
            <code>test</code> oder
            <code>it</code>
          </p>
          <pre><code data-trim contenteditable>test('it should work', () => {
    expect(...).toBe(...);
  });</code></pre>
          <pre><code data-trim contenteditable>it('it should also work', () => {
    expect(...).toBe(...);
  });</code></pre>
        </section>
        <section>
          <h2>Testsuites</h2>
          <ul>
            <li>Testsuites (optional, müssen nicht verwendet werden)
              <pre><code data-trim contenteditable>describe('some feature', () => {
    test('test 1', () => {...});
    test('test 2', () => {...});
    test('test 3', () => {...});
  });</code></pre>
            </li>
            <li class="fragment">Überspringen (
              <code>skip</code>) / Auswählen (
              <code>only</code>) einzelner Tests:
              <pre><code data-trim contenteditable>describe.only('some feature', () => { } );
describe.skip('another feature', () => { });
  
test.only('should work', () => { });
test.skip('does not work, skip for now', () => { });
  
  </code></pre>
  
            </li>
          </ul>
        </section>
        <section>
          <h2>Expectations und Matcher</h2>
          <div class="fragment">
            <p>
              <code>expect()</code> liefert eine <em>Expectation</em> zurück, auf der <em>Matcher</em> definiert sind:</p>
            <pre><code data-trim contenteditable>expect(actual).toXyz(expected);
  // for example:
  expect("Hello Jest").toBe("Hello Jest"); // => ok
  </code></pre>
          </div>
          <div class="fragment">
            <p>Einige Matcher</p>
  
            <pre><code data-trim contenteditable>// Vergleich auf Identität
  expect(actual).toBe(expected);
  // Inhaltsvergleich:
  expect(actual).toEqual(expected);
  // true / false / null:
  expect(actual).toBeTruthy();
  expect(actual).toBeFalsy();
  expect(actual).toBeNull();
  // Länge (Array oder String)
  expect(actual).toHaveLength(123);
  </code></pre>
          </div>
          <p class="fragment">
            <a href="https://facebook.github.io/jest/docs/expect.html#content">https://facebook.github.io/jest/docs/expect.html#content</a>
          </p>
  
        </section>
  
        <section>
            <h2>Mock Funktionen (in Jest)</h2>
            <ul>
                <li class="fragment"><code>jest.fn()</code> erzeugt eine Mock-Funktion
                    <pre><code data-trim contenteditable>// Liefert undefined zurück, wenn ausgeführt
const aMockFn = jest.fn();

aMockFn(); // => undefined
                    </code></pre>
                <li class="fragment">Implementierung der Mockfunktion kann als Parameter übergeben werden:
                    <pre><code data-trim contenteditable>
const aMockFn = jest.fn( param => `Hello, ${param}` );

console.log(aMockFn('World'));
// => Hello, World
                </code></pre>
                </li>
            </ul>
        </section>
        <section>
            <h2>Mock Funktionen</h2>
            <li class="fragment">Aufrufe sicherstellen
                <pre><code data-trim contenteditable>
const aMockFn = jest.fn( param => `Hello, ${param}` );
// use aMockFn somewhere in your code, then assert:

expect(aMockFn).toHaveBeenCalled();
expect(aMockFn).toHaveBeenCalledWith('World');
</code></pre>
            </li>
            <li class="fragment">Aufrufe: <code>fn.mock.calls</code>
                <pre><code data-trim contenteditable>
const mockFn = jest.fn();
mockFn('Hello', 'World');
expect(mockFn.mock.calls).toHaveLength(1);
expect(mockFn.mock.calls[0].toBe(['Hello', 'World']);
</code></pre>
            </li>
            <li class="fragment">Zurücksetzen: Reset
                <pre><code data-trim contenteditable>
const mockFn = jest.fn();
mockFn('Hello', 'World');
expect(mockFn.mock.calls).toHaveLength(1);
jest.restAllMocks(); // or: mockFn.mockReset();
expect(mockFn.mock.calls).toHaveLength(0);
            </code></pre>
            </li>
        </section>
        <section>
            <h2>Mock modules</h2>
            <li class="fragment">Ein Modul mocken:
                <pre><code data-trim contenteditable>
// external module:
jest.mock('react-dom');
// internal module:
jest.mock('../../app/myDataService');

// alle Funktionen sind jetzt gemockt,
// "leere" Implementierung, return undefined)
</code></pre>
            </li>
            <li class="fragment">Implementierung für Mockfunktion:
                <pre><code data-trim contenteditable>
jest.mock('../../app/myDataService', () => ({
  loadData: jest.fn( () => ({data: 'mock data'}) );
});

console.log(myDataService.loadData());
// => {data: 'mock data'}
</code></pre>
            </li>
        </section>
        <section>
            <h2>Mock modules</h2>
            <li class="fragment">Funktionen aus gemockten Modulen sind Jest Mock Funktionen
                <pre><code data-trim contenteditable>
import myDataService from '../../app/myDataService';
jest.mock('../../app/myDataService');

// do something in code, that uses my dataservice
expect(myDataService).toHaveBeenCalled();

</code></pre>
            </li>
        </section>

        <section>
          <h3>Testen von React Komponenten, Teil 1</h3>
          <h2>Rendering</h2>
        </section>
       
  
        <section>
          <h3>React Test Renderer</h3>
          <p>
            <a href="https://www.npmjs.com/package/react-test-renderer">https://www.npmjs.com/package/react-test-renderer</a>
          </p>
          <p>Rendert React Komponenten in JSON Objekte (ohne DOM):</p>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>import renderer from 'react-test-renderer';
  
const component = renderer.create(
  &lt;GreetingMaster greetings={someGreetings} />
);
  
console.log(component.toJSON());
          </code></pre>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>
  { type: 'div',
    props: {},
    children:  [
      { type: 'table', props: {}, children: [Object] },
      { type: 'button', props: [Object], children: [Object] }
    ]
  }
          </code></pre>
        </section>
        <section>
          <h3>"Snapshot Testing" mit Jest</h3>
          <p>
            <code>expect(obj).toMatchSnapshot()</code> vergleicht ein JSON-Objekt mit einer gespeicherten Datei:</p>
          <ul>
            <li class="fragment">Bei
              <b>erster</b> Ausführung: legt Snapshot-File an (
              <a href="images/jest-snapshot-file.png" target="_blank">Beispiel</a>)
              <ul>
                <li class="fragment">Snapshotdateien werden in Git versioniert</li>
              </ul>
            </li>
            <li class="fragment">Bei
              <b>folgenden</b> Ausführungen: erzeugt neuen Snapshot und vergleicht mit gespeichtertem Snapshot
            </li>
            <li class="fragment">Wenn Snapshots unterschiedlich
              <ul>
                <li>Fehler samt Diff (
                  <a href="images/jest-snapshot-diff.png" target="_blank">Beispiel</a>)</li>
                <li>Im Watch Mode kann Snapshot aktualisiert werden
                  <img src="images/jest-snapshot-update.png">
                </li>
              </ul>
            </li>
  
          </ul>
        </section>
  
        <section>
          <h3>Snapshot Testing mit Jest und React</h3>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>import renderer from 'react-test-renderer';
  
  test('it should render correctly', () => {
  
  const someGreetings = [ . . . ];
  
  const component = renderer.create(
    &lt;GreetingMaster greetings={someGreetings} />
  );
  
  expect(component.toJSON()).toMatchSnapshot();
});
          </code></pre>
          <p class="fragment">
            <em>Snapshot sagt nicht, ob UI richtig oder falsch gerendert wird, sondern nur, ob sie verändert wurde!</em>
          </p>
        </section>
  
        <section>
          <h3>Testen von React Komponenten, Teil 2</h3>
          <h2>Interaktion</h2>
        </section>

        <section>
          <h3>Enzyme</h3>
          <p>
            <em>JavaScript Testing utilities for React (
              <a href="http://airbnb.io/enzyme/" target="_blank">http://airbnb.io/enzyme/</a>)</em>
          </p>
          <p>Bibliothek mit Funktionen zum Testen von React Komponenten</p>
          <ul>
            <li class="fragment">Rendern von Komponenten:
              <ul>
                <li>
                  <b>shallow</b> zum "flachen" Rendern einer Komponente</li>
                <li>
                  <b>mount</b> zum Rendern einer Komponete in einen (headless) DOM, z.B. jsdom</li>
              </ul>
            </li>
            <li class="fragment">Navigieren durch den DOM und Suchen von Elementen und Komponenten</li>
            <li class="fragment">Modifizieren von Komponenten und Auslösen von Events</li>
          </ul>
        </section>
  
        <section>
          <h3>Testen einer Komponente mit Jest und Enzyme</h3>
          <pre class="fragment"><code class="javascript" contenteditable data-trim>import {mount} from 'enzyme';
  import GreetingController from '...';
  import GreetingDetail from '...';
  
  test('it should open detail view on button click', () => {
    // mount the component into a real dom (implemented by JSDom)
    const component = mount(&lt;GreetingController  />);
  
    // on initial render the list with greetings (GreetingMaster)
    // is visible but no GreetingDetail
    expect(component.find(GreetingDetail)).toHaveLength(0);
  
    // find the "add" Button...
    const addButton = component.find('button');
  
    // click on the button
    addButton.simulate('click');
  
    // now the GreetingDetail should be visible
    expect(component.find(GreetingDetail)).toHaveLength(1);
  });
          </code></pre>
        </section>
  
        <section>
            <h3>Ausblick: Testen von asynchronem (React) Code</h3>
            <p><a href="https://github.com/nilshartmann/jest-playground" target="_blank">Beispiel mit mehreren möglichen Strategien</a></p>
          </section>

          <section>
            <h2>Übung: React Komponente mit Jest und Enzyme testen</h2>
            <p><em>Vervollständige Testfälle für die GreetingMaster Komponente</em></p>
            
            <ol>
              <li>Kopiere <p><code>code/material/4-test/test</code> <br/>nach <code>code/workspace</code></p>(so dass <code>code/workspace/test</code> entsteht)</li>
              <li>In der Datei sind TODOs mit den Aufgaben hinterlegt</li>
              <li>Du kannst die Tests mit <code>npm test</code> ausführen ("watch"-Modus, werden bei jeder Änderung neu ausgeführt)</li>
            </ol>
          </section>

          <!-- =========================================== AUSBLICK ===================== -->

          <section>
            <h1>Aus- und Überblick</h1>
            <h3>Weiterführende Themen</h3>
        </section>
        
      <section id="t-redux">
        <h1>Zustands-Management mit Redux</h1>
    </section>

    <section>
      <h2>Eine typische React-Anwendung in Komponenten</h2>
      <h3>Frage an Euch: was könnte es für Probleme geben?</h3>
      <img src="images/typische-react-komponenten-hierarchie.png"  style="height:650px"  />
    </section>

    <section>
        <h3>Problem 1: Über Komponenten verteilter Zustand</h3>
        <img src="images/verteilter-zustand.png"  style="height:650px" />
        <p>Wo muss ich nach Fehlern suchen? Wo ist die Logik?</p>
    </section>

    <section>
      <h3>Problem 2: Getrennte Komponentenhierarchien</h3>
      <img src="images/zwei-komponenten-hierarchien.png" style="height:650px"  />
      <p>Geht entweder nicht oder "Gott-Komponente" entsteht</p>
  </section>

  <section>
    <h3>Problem 3: Gemeinsamer ("globaler") Zustand</h3>
    <img src="images/gemeinsam-genutzter-state.png"  style="height:650px" />
    <p>Wie kommt Zustand von ganz oben nach ganz unten?</p>
</section>

<section>
  <h3>Problem 4: UI und Logik vermischt</h3>
  <img src="images/ui-und-logic-vermischt.png"  style="height:650px" />
  <p>Wiederverwendung? React-unabhängigkeit? Testbarkeit?</p>
</section>

<section>
  <h3>External Statemanagement</h3>
  <div  class="fragment">
  <p>Habt ihr Ideen?</p>
  <p>Wie können wir Zustand und/oder Logik aus den Komponenten befreien?</p></div>
</section>

<section>
    <h2>Redux</h2>
    <h3>External Statemanagement</h3>
  </section>
  
<section>
  <h3>Wiederholung</h3>
    <h2>Render Cycle in Pure React</h2>
    <img src="images/redux-01-react-cycle-no-redux.png"  style="height:650px"/>
</section>

    <section>
        <h2>Redux extrahiert die Verantwortlichkeiten</h2>
        <img src="images/redux-02-extracting-responsibility.png" style="width: 900px"/>
    </section>
    <section>
        <h2>Demo: Redux & Redux Devtools</h2>
        <a href="http://localhost:8080/" target="_blank">Ziel-Anwendung</a>
        <p>(npm start in code/schritte/redux/7-redux-complete-app)</p>
    </section>

    <section>
        <h2>Redux Schritt-für-Schritt</h2>
        <p>Wir stellen eine Komponente auf Redux um</p>
        <p>(Verzeichnis: <code>workspace-redux</code>)</p>
    </section>

    <section>
        <h2>Strukturierter Überblick über alle Redux Teile</h2>
    </section>

    <section>
        <h3>Event-Handlers werden Action-Creators</h3>
        <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
export const setFilter = filter => {
return {
    type: SET_FILTER,
    filter
};
}
</code></pre>
        <ul>
            <li class="fragment">Action-Creators erzeugen Action-Objekte</li>
            <li class="fragment">Actions sind Kommando-artige Strukturen von Dingen, die die Applikation tun soll
            <li class="fragment">Über die dispatch-Methode des Stores werden sie an <em>alle</em> Reducer weiter gegeben
            <li class="fragment">Actions bestehen aus einem Typen und einer beliebigen Nutzlast (payload)</li>
        </ul>
    </section>

    <section>
        <h3>Action-Creators machen Server-Calls</h3>
        <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
export const loadGreeting = greetingId => dispatch => {
fetch(BACKEND_URL+'/'+greetingId)
    .then(response => response.json())
    .then(greetings => dispatch({
        type: SET_GREETINGS,
        greetings
    });
};
</code></pre>
        <ul>
            <li class="fragment">Die Action wird nicht direkt zurück geliefert, sondern erst später dispatched</li>
            <li class="fragment">wir bekommen die dispatch Methode als Parameter, mit der wir später
                die Action dispatchen</li>
        </ul>
        <p  class="fragment"><strong>Action-Creators sind die einzigen Teile einer Redux-Anwendung, die asynchrone Operationen
            ausführen dürfen</strong></p>
    </section>

    <section>
        <h3>Ein <em>einziger</em> Store hält den <em>kompletten</em> Zustand</h3>
        <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
import { Provider } from 'react-redux';
import { createStore } from 'redux';
import { rootReducer } from './reducers';

// http://redux.js.org/docs/api/createStore.html
const store = createStore(
rootReducer // reducer
);
ReactDOM.render(
&lt;Provider store={store}>
    &lt;GreetingController />
&lt;/Provider>,
mountNode
);
    </code></pre>
        <ul>
            <li class="fragment">Zentraler Teil der Anwendung
            <li class="fragment">Liefert die bereits bekannte dispatch-Methode
            <li class="fragment">Der Store wird allen Componenten über die Wrapper-Komponenten <em>Provider</em>
                zur Verfügung gestellt
        </ul>
    </section>

    <section>
        <h3>Middleware zwischen Dispatch und Store</h3>
        <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
import { applyMiddleware } from 'redux';
import thunk from 'redux-thunk';

const store = createStore(
rootReducer, // reducer
applyMiddleware(thunk) // middleware as enhancer
);
    </code></pre>
        <ul>
            <li class="fragment">Die Thunk Middleware dient als de-facto-Standard</li>
            <li class="fragment">Gibt die dispatch-Methode and (asynchrone) Action Creators weiter
            <li class="fragment"><a href="https://github.com/gaearon/redux-thunk#whats-a-thunk" target="_blank">
                'A thunk is a function that wraps an expression to delay its evaluation'
            </a></li>
            <li class="fragment">Middleware ist ein fortgeschrittenes Feature und meistens genügt die Thunk Middleware</li>
        </ul>
    </section>

    <section>
        <h3>Reducers enthalten die Kern-(Business)-Logik</h3>
        <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
import {combineReducers} from 'redux';

// http://redux.js.org/docs/api/combineReducers.html
export const rootReducer = combineReducers({
greetings, // updates greeting partial state
filter,
mode
});
    </code></pre>
        <ul>
            <li class="fragment">Reducer sind pure Funtionen, die den alten Zustand und eine Action bekommen und einen neuen Zustand erzeugen
            <li class="fragment">Oft bearbeitet ein Reducer nur einen Teil des Zustands
        </ul>
    </section>

    <section>
        <h3>Teil-Reducer</h3>
        <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
const mode = (state = MODE_MASTER, action) => {
switch (action.type) {
    case SET_MODE:
        return action.mode;
    default:
        return state;
}
};
    </code></pre>
        <ul>
            <li class="fragment">Initialisiert seinen Teilzustand (oft mit einem Default-Parameter)</li>
            <li class="fragment">Ändert niemals zustand direkt</li>
            <li class="fragment">Sondern liefert einen neuen Zustand (manchmal teilweise als Kopie)
        </ul>
    </section>

    <section>
        <h3>Zustand mit Komponenten verbinden</h3>
        <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
import { connect } from 'react-redux';

import * as actions from './actions';

export default connect(
state => ({
    mode: state.mode
    // ...
}),
actions
)(GreetingController);
        </code></pre>
        <ul>
            <li class="fragment">der Provider gibt den Store in alle Komponenten</li>
            <li class="fragment">Die Connect-Funktion extrahiert daraus Zustand, der als Property an Komponenten übergeben wird
            <li class="fragment">Action-Creators können ebenso in Komponent gegeben werden</li>
        </ul>
    </section>

    <section>
        <h3>Verwendung von Zustand und Action-Creators in verbundenen Komponenten</h3>
        <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
class GreetingController extends React.Component {
render() {
    // state from store
    const {aggregatedGreetings, greetings, mode} = this.props;
    // action creators bound to dispatch from store
    const {setMode, saveGreeting, setFilter} = this.props;

    // ...
}
}
        </code></pre>
        <ul>
            <li class="fragment">Action-Creators und Zustand werden in Properties hinein gemerged
            <li class="fragment">Diese werden mit ES6-Destructuring an den Stellen aufgelöst wo wir sie brauchen
            <li class="fragment">Die Komponenten wird nur neu gerendert wenn sich der benutzte Zustand verändert</li>
        </ul>
    </section>

    <section>
        <h2>Zusammenfassung Redux-Architektur</h2>
        <img src="images/redux-03-resulting-redux-architecture.png" style="max-height:650px" />
    </section>

    <section>
        <h3>Lokaler State ist weiterhin erlaubt!</h3>
        <p>Es gibt unterschiedliche Arten von "State"</p>

        <img src="images/three-kinds-of-state.png"  style="max-height:650px" />
        
      </section>

      <section id="t-context">
          <h2>Context API</h2>
          <a href="code/schritte/context/public/index.html" target="_blank">Ziel-Anwendung</a>
        </section>

        <section>
            <h2>Problem</h2>
            <h3>Zentrale Daten, die an vielen Stellen benötigt werden</h3>
            <img src="images/context-screenshot.png" style="max-height:650px" /> 
          </section>
          <section>
              <h2>Ansatz 1: Properties durchreichen</h2>
              <img src="images/context-props.png" style="max-height:650px" /> 
            </section>
            <section>
                <h2>Ansatz 2: React Context</h2>
                <img src="images/context-context.png" style="max-height:650px" /> 
            </section>

            <section>
              <h2>Context...</h2> 
              <p><em>erlaubt das Durchreichen von Informationen ohne explizites
                  angeben als Properties</em>               
              <ul>
                <li class="fragment">funktioniert nur innerhalb einer Hierarchie-Ebene</li>
                <li class="fragment">es können beliebg viele (fachliche) Context definiert werden</li>
                <li class="fragment">besteht aus <code>Provider</code> und <code>Consumer</code></li>
                <li class="fragment"><a href="https://reactjs.org/docs/context.html" target="_blank">Doku</a></li>
                </ul>
            </section>

            <section>
                <h2>Context Factory</h2>    
                <p><em>erzeugt ein Objekt, mit <b>zwei Komponenten</b></em></p>            
                <ul>
                  <li class="fragment"><code>Provider</code>, stellt Objekt mit Key-Value-Paaren zur Verfügung (der Context-"Value")
                  </li>
                  <li class="fragment"><code>Consumer</code> wird in eigener Komponente verwendet, um auf einen Context zuzugreifen</li>
                  </ul>
                  <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
                      import react from "React" from "react-router-dom";

                      const ThemeContext = React.createContext();

                      // erzeugt:
                      // ThemeContext.Provider 
                      // ThemeContext.Consumer
                              </code></pre>
                                        

              </section>

              <section>
                <h2>Context Provider</h2>
                <p><em>Eine React-Komponente, die einen Context zur Verfüng stellt</em></p>
                <ul>
                  <li class="fragment">wird innerhalb einer eigenen Komponente in <code>render</code> eingebunden</li>
                  <li class="fragment">Nimmt ein Objekt ("Context") mit beliebigen Werten entgegen</li>
                  </ul>
                  <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
                      const ThemeContext = React.createContext();

                      class ThemeProvider extends React.Component {
                        render() {
                          const contextValue = {
                            // the current theme
                            theme: this.state.theme,
                      
                            // function to set new theme
                            setTheme: name => this.setState({theme: name})
                          };
                      
                          return &lt;ThemeContext.Provider value={contextValue}>
                            {this.props.children}
                          &lt;/ThemeContext.Provider>;
                        }
                      }                    
</code></pre>
                  </section>

                  <section>
                    <h2>Context Consumer</h2>
                    <p><em>Eine React-Componente, die einen bestimmt Context konsumiert</em></p>

                    <ul>
                    <li class="fragment">Mit "<code>static contextType = ...</code>"" kann ein bestimmter Context referenziert werden</li>
                    <li class="fragment">Context-Objekt steht dann über <code>this.context</code> zur Verfügung</li>
                    <li class="fragment">Komponente wird neu gerendert, wenn Context sich ändert</li>
                    </ul>
                    <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
                    import ThemeContext from "...";

                    class GreetingDetail extends React.Component {
                      static contextType = ThemeContext;

                      render() {
                        // this.context ist Objekt aus dem ThemeContext.Provider
                        // z.B.:
                        return &lt;div className={this.context.theme}>...&lt;/div>
                      }
                    }
                      </code></pre>
                  </section>

                  <section>
                    <h2>Mehrere Context Consumer</h2>
                    <p>Als Render-Property</p>
                    <ul>
                      <li class="fragment">Die <code>MyContext.Consumer</code>-Komponente kann direkt verwendet werden</li> 
                      <li class="fragment">Als Children wird dort JSX-Element, sondern eine <b>Callback-Funktion</b> übergeben</li>
                      <li class="fragment">Die Funktion erthält als Parameter das Context Objekt</li>
                        <li class="fragment">Die Funktion verwendet den Context und liefert JSX zurück</li>
                        <li class="fragment">Mehrere Consumer können verschachtelt werden</li>
                    </ul>
                    <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
                        import ThemeContext from "...";
    
                        function GreetingMaster(props) {
                          return &lt;ThemeContext.Consumer>
                            { themeContext => {
                              return &lt;div className={themeContext.theme}>...&lt;/div>
                            }}
                            &lt;/ThemeContext.Consumer>;
                        }
                          </code></pre>
                      </section>
          

      <section id="t-router">
          <h2>Client-seitiges Routing (Überblick)</h2>
          <a href="code/schritte/router-v4-typescript/public/index.html" target="_blank">Ziel-Anwendung</a>
        </section>
        <section>
          <h2>Warum Routing?</h2>
          <span>
            <p>Mappen von URLs auf Komponenten
              <br>
              <span style="font-size: 80%">(Navigation findet ohne Server-Roundtrip statt)</span>
            </p>
          </span>
          <span>
            <p>Komponenten halten (Teil) des Zustandes der Anwendung
              <br>
              <span style="font-size: 80%">Welche Komponente ist sichtbar (Master oder Detail)?</span>
              <br>
              <span style="font-size: 80%">Welche Daten werden dafür geladen (z.B. Greeting Id)</span>
            </p>
          </span>
        </section>
  
        <section>
          <h2>Herausforderungen</h2>
          <p>Auf Änderungen der URL reagieren
            <br>
            <span style="font-size: 80%">Ableiten des Zustandes aus der URL
              <br>Wenn sich die URL ändert, kein Server roundtrip</span>
          </p>
          <p>Hierarchische Komponentenstrukturen</p>
          <p>Beim Klick auf Links etc aktualisieren der URL</p>
        </section>
  
        <section>
          <h2>React Router</h2>
          <ul>
            <li>Kein Bestandteil von React</li>
            <li>Sehr häufig verwendet (de-facto Standard)</li>
            <li>Aktuelle Version 4:
              <a href="https://reacttraining.com/react-router/" target="_blank">
                https://reacttraining.com/react-router/</a>
            </li>
          </ul>
        </section>
        <section>
          <h3>Das Router-Objekt</h3>
          <p class="fragment">Top-Level-Objekt, das einmalig (oben) in der Komponenten Hierarchie eingebunden werden muss</p>
          <p class="fragment">Mehrere Ausprägungen zum Arbeiten mit den URL und der Browser History:</p>
            <ul>
              <li class="fragment">
                <b>HashRouter</b>: codiert Pfad in angehängten Hash (#/greetings)</li>
              <li class="fragment">
                <b>BrowserRouter</b>: codiert Pfad direkt in URL (/greetings)</li>
            </ul>
          <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
  import {HashRouter as Router} from "react-router-dom";
  
  const app = &lt;Router>&lt;GreetingController/>&lt;/Router>;
  
  ReactDOM.render(app, document.getElementById(...));
          </code></pre>
        </section>
  
        <section>
          <h3>Welche Komponente soll für einen Pfad gerendert werden</h3>
          <p class="fragment">Das
            <code>Route</code>-Objekt mappt Pfade auf Komponenten</p>
          <ul>
            <li class="fragment">
              Wird verwendet, wo Pfad-abhängig Komponenten ausgewählt werden sollen
              <ul>
                <li>vergleichbar mit intelligentem
                  <code>if</code>/
                  <code>switch</code> statement</li>
                <li><b>Kann überall in der Anwendung</b> verwendet werden (auf allen Hierarchie-Ebenenen) </li>
              </ul>
            </li>
            <li class="fragment">Mit
              <code>path</code> wird der Pfad übergeben, für den die Route matchen soll</li>
            <li class="fragment">Mit
              <code>component</code> wird die Komponente übergeben</li>
          </ul>
          <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
  import {HashRouter as Router, Route} from "react-router-dom";
  
  const app = &lt;Router>
    &lt;Route path="/greet/:greetingId" component={GreetingDisplayController}/>
    &lt;Route path="/" component={GreetingController}/>
  &lt;/Router>;
  
  ReactDOM.render(app, document.getElementById(...));
          </code></pre>
        </section>
        <section>
          <h3>Route #2: Das render-Property</h3>
          <ul>
            <li>Statt einer Komponente kann eine Funktion übergeben werden, die eine Komponente zurückliefert</li>
            <li>Ermöglicht es, zusätzliche Properties an die Komponente zu übergeben</li>
            <li>Kann unterschiedliche Komponenten zurückliefern (z.B. für Authorisierung) </li>
            <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
  &lt;Route path="/"
    render={() => {
      return loggedIn ? 
        &lt;GreetingMaster greetings={initialGreetings} />
      :
        &lt;LoginForm />
    }}
  />
          </code></pre>
          </ul>
        </section>
        <section>
          <h3>Hintergrund: Pfade</h3>
          <p>In Routen werden
            <b>Pfade</b> angegeben, die mit der aktuellen URL verglichen werden
            <ul>
              <li>Pfade sind per Default gültig für Teilstrings</li>
              <li>Mit
                <code>exact</code> kann das Verhalten verändert werden
                <li>Eine Route ohne
                  <code>path</code> matcht immer</li>
            </ul>
            <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
  // trifft zu für / und /greeting
  &lt;Route path="/" component={GreetingController}/>
  
  // trifft nur zu für /
  &lt;Route path="/" exact component={GreetingController}/>
  
  // passt auf jede URL:
  &lt;Route component={GreetingController}/>
  
          </code></pre>
            <ul>
              <li class="fragment">Kann variable Segmente enthalten:
              </li>
            </ul>
            <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
  &lt;Route path="/greeting/:greetingId"
        component={&lt;GreetingDisplay />} />
  
  // in GreetingDisplay kann die greetingId über
  // this.props.match.params.greetingId abgefragt werden
          </code></pre>
  
  
        </section>
        <section>
          <h3>Switch</h3>
          <ul>
            <li class="fragment">Wenn mehrere path-Ausdrücke matchen, werden mehrere Komponenten gerendert (z.B. "/" und "/greetings")</li>
            <li class="fragment">
              <code>Switch</code> sorgt dafür, dass nur die erste Komponente im Block gerendert wird</li>
          </ul>
          <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
  import {HashRouter as Router, Route, Switch} from "react-router-dom";
  
  const app = (
    &lt;Router>
      &lt;Switch>
        &lt;Route path="/greet/:greetingId" component={GreetingDisplayController}/>
        &lt;Route path="/" component={GreetingController}/>
  
        // "No match": ohne Pfad
        &lt;Route component={NotFoundPage}/>
  
      &lt;/Switch>
    &lt;/Router>
  );
  
  ReactDOM.render(app, document.getElementById(...));
          </code></pre>
        </section>
  
        <section>
          <h3>Router Properties für Komponente</h3>
          <p>Der Router übergibt automatisch drei Properties an die gerenderte Komponente:</p>
          <ul>
            <li class="fragment">
              <code>match</code>: Enthält u.a. die Parameter aus dem Pfad (
              <code>match.params.xyz</code>)</li>
            <li class="fragment">
              <code>history</code>: Zum Arbeiten mit der History (z.B.
              <code>push()</code> zum Navigieren)</li>
            <li class="fragment">
              <code>location</code>: Der aktuelle Pfad (z.B.
              <code>pathname</code>,
              <code>search</code>)</li>
          </ul>
          <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
  const HelloComponent = ({match, history, location}) => (
    &lt;div>
      &lt;h1>Hello, {match.params.name}&lt;/h1>
      &lt;small>The current path is: {location.pathname}&lt;/small>
      &lt;button onClick={() =&gt; history.push('/greetings')}>Show Greetings&lt;/button>
    &lt;/div>
  );
  
  // ...
  &lt;Route path="/greet/:name" component={HelloComponent}/>
  
          </code></pre>
          <ul>
            <li class="fragment">Die Properties werden auch an die
              <code>render</code>-Funktion einer
              <code>Route</code> als Parameter übergeben
            </li>
          </ul>
          <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
   &lt;Route path="/somewhere" render={({match, history, location}) => . . . }/>
            
                    </code></pre>
        </section>
  
        <section>
          <h3>Links</h3>
          <p>Mit
            <code>Link</code> und
            <code>NavLink</code> können Links erzeugt werden</p>
          <ul>
            <li>Mit
              <code>to</code> wird das Ziel angegeben</li>
            <li>Gerendert wird per default ein
              <code>a</code> Element</li>
            <li>URL wird entsprechend der History (Browser oder Hash) erzeugt</li>
            <li>Mit
              <code>activeClassName</code> und
              <code>activeStyle</code> auf
              <code>NavLink</code> können Styles übergeben werden, die angewendet werden, wenn der Link der aktiven Route entspricht
          </ul>
          <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
  import {Link, NavLink} from "react-router-dom";
  
  &lt;Link to='/greetings'>Show all greetings&lt;/Link>
  
  // Erzeugtes 'a' Element erhält 'highlight' CSS-Klasse, wenn die aktive Route
  &lt;NavLink to='/greeting/me' activeClassName="highlight">Greet me&lt;/NavLink>
  
          </code></pre>
        </section>
  
        <section>
          <h3>Das history-Objekt</h3>
          <p class="fragment">Mit dem
            <code>history</code>-Objekt kann mit der Browser History interagiert werden</p>
          <p class="fragment">Es gibt verschiende Implementierungen (insb BrowserHistory und HashHistory sowie "memory history" für Testen)</p>
          <p class="fragment">Mit der History kann auf andere URLs gesprungen werden oder die Location abgefragt werden</p>
          <p class="fragment">Route-Komponenten erhalten die history automatisch per Property</p>
          <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
  function GreetingController({history}) {
    // gehe zu neuer URL
    history.push("/..."); 
  
    // gehe zu neuer URL, lösche aber aktuelle aus History im Browser
    history.replace("/...") 
  
    // aktuelle URL
    const currentPath = history.location.pathname; 
  }
          </code></pre>
        </section>
  
        <section>
          <h3>Zugriff auf die history außerhalb von "Route Components"</h3>
          <ul>
            <li class="fragment">Komponenten, die von
              <code>Route</code> gerendert werden, erhalten automatisch Zugriff auf
              <code>history</code> etc</li>
            <li class="fragment">Für alle anderen Komponenten, brauchen wir eine andere Lösung</li>
            <li class="fragment">
              <code>withRouter</code> HOC "erweitert" Komponenten und Router Properties</li>
          </ul>
          <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
  import {withRouter} from "react-router-dom";
  
  function GreetLink(props) {
    const greeting = this.props.greeting; // übergeben vom ursprünglichen Aufrufer
    const history = this.props.history; // übergeben von withRouter
    return &lt;div>
      &lt;button onClick={() =&gt; history.push(`/${greeting.id}`)}>Show Greeting&lt;/button>
    &lt;/div>;
  }
  
  // 
  export default withRouter(GreetingLink);
                    </code></pre>
        </section>
        <section>
          <h3>withRouter zur Laufzeit</h3>
          <img src="./images/screenshot-withRouter.png" />
        </section>
  
        <section>
          <h3>Hintergrund</h3>
          <h2>Higher-Order Components (HOC)</h2>
          <p>https://reactjs.org/docs/higher-order-components.html</p>
          <p>Eine Higher-Order Komponente ist eine Funktion, die
            <b>eine Komponente entgegennimmt und eine neue Komponente zurückliefert</b>
          </p>
          <p class="fragment">Die Higher-Order-Kommponente ist für das
            <b>rendern</b> der ursprünglichen Komonente verantwortlich
          </p>
            <ul class="fragment">
              <li>Sie kann das Rendern bei Bedarf auch unterdrücken oder verzögern</li>
              <li>Sie hat Zugriff auf alle ursprünglichen Properties</li>
              <li>Sie kann der Ziel-Komponente zusätzliche Properties übergeben oder welche entfernen</li>
            </ul>
  
        </section>
        <section>
          <h3>Beispiel: Higher-Order Components (HOC)</h3>
          <p>Ziel:
            <em>Eine HOC, die ein Greeting lädt das geladene Greeting an die ursprüngliche Komponente weitergibt</em>
          </p>
          <div style="font-size:85%">
            <p>Vorteile:
              <ul>
                <li>"Komplexe" Logik zum Laden der Daten, Fehlerbehandlung etc, liegt zentral in der HOC</li>
                <li>Die gewrappte Komponente muss sich nicht um das (technische) Laden kümmern</li>
                <li>Die gewrappte Komponente benötigt keinen Lifecycle, sie wird nur dargestellt, wenn ein Greeting vorhanden ist</li>
              </ul>
          </div>
          <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
    
  // GreetingDisplayController.js          
  // GreetingDisplayController (stellt einen Gruß dar):
  function GreetingDisplayController({greeting}) {
    return &lt;h1>&lt;{greeting.name}, {greeting.greeting}&lt;/h1>;
  }
    
  // umschliessen mit der HOC
  export default withGreeting(GreetingDisplayContainer);
  </code></pre>
          <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
  // Verwender
  import GreetingDisplayController from "...";
  // dass es sich um eine HOC handelt, ist für den Verwender transparent:
  &lt;GreetingDisplayController greetingId={3} />
                                    </code></pre>
        </section>
        <section>
          <h3>Beispiel: Higher-Order Components (HOC)</h3>
            <p>Schritt 1: HOC definieren</p>
            <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
    
    // Schritt 1: stumpfes Wrappen einer Komponente.
    function withGreeting(RawComponent) {
      return class extends React.Component {
        render() {
          // mit {...this.props} werden alle Properties, die der HOC übergeben
          // wurden,  an die Ziel-Komponente übergeben
          return &lt;RawComponent {...this.props} />
        }
      }
                                    </code></pre>
        </section>
        <section>
          <h3>Beispiel: Higher-Order Components (HOC)</h3>
            <p>Schritt 2: Lifecycle-Methoden ("fachliche" Logik der HOC) implementieren</p>
            <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
  function withGreeting(RawComponent) {
    return class extends React.Component {
    
      // HOC ist "normale" Komponente, dh wir habe Lifecycle-Methoden etc
      componentDidMount() {
        // GreetingId kommt aus den Props, mit dem die HOC aufgerufen wurde
        const greeting = loadGreeting(this.props.greetingId);
        this.setState({greeting});
      }
  
      componentWillReceiveProps(nextProps) {
        // analog: greeting lesen und State setzen
      }
    
      render() { . . . }
    }
  }
                                      </code></pre>
        </section>
        <section>
          <h3>Beispiel: Higher-Order Components (HOC)</h3>
            <p>Schritt 3: Implementieren der render-Methode</p>
            <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
    function withGreeting(RawComponent) {
      return class extends React.Component {
      
        componentDidMount() { ... }
    
        componentWillReceiveProps(nextProps) { ... }
          // analog: greeting lesen und State setzen
        }
      
        render() { 
          if (!this.state.greeting) {
            // Greeting noch nicht geladen
            return null;  
            // alternativ: Loading Spinner zeigen, Fehlerbehandlung o.ä.
          }
  
          // Ziel-Komponente erhält geladenes Greeting als
          // 'greeting' Property
          return &lt;RawComponent greeting={this.state.greeting} />
        }
      }
    }
                                        </code></pre>
        </section>
        <section>
          <h3>Beispiel: Higher-Order Components (HOC)</h3>
            <p>Schritt 4: Verwenden der HOC</p>
            <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
  import withGreeting from ". . .";
  
  // GreetingDisplayController kennt kein greetingId-Property, 
  // nur das geladene Greeting
  function GreetingDisplayController({greeting}) { . . .};
  
  export default withGreeting(GreetingDisplayController);
                                          </code></pre>
            <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
  import GreetingDisplayController from ". . .";
  
  // Verwender übergibt nur das greetingId-Property, 
  // nicht das geladene Greeting
  &lt;GreetingDisplayController greetingId={7} />
                                          </code></pre>
        </section>
        <section>
          <h2>Alternative PropTypes</h2>
          <p>https://reactjs.org/docs/render-props.html</p>
          <p>https://www.youtube.com/watch?v=BcVAq3YFiuc</p>
        </section>
  
        <section>
          <h2>Der Router mit TypeScript</h2>
        </section>
  
        <section>
          <h3>RouteComponentProps</h3>
          <p>Der Router übergibt Properties an eine Route-Komponente</p>
          <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
  // GreetingController erhält history etc als Property          
  &lt;Route component={GreetingController} />
                                                      </code></pre>
          <p class="fragment">Die Route-Properties sind im Interface
            <code>RouteComponentProps</code> definiert</p>
          <p class="fragment">Die Komponente kann für ihre Properties das Interface erweitern:</p>
          <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
  import { RouteComponentProps } from "react-router";
  interface GreetingControllerProps extends RouteComponentProps&lt;void&gt { 
    // ggf. eigene Properties des GreetingControllers
  }
  class GreetingController extends React.Component&lt;GreetingControllerProps> {
    render() {
      const history = this.props.history; // ok, kein Compile-Fehler
    }
  }
  </code></pre>
        </section>
        <section>
          <h3>RouteComponentProps #2</h3>
          <p>Der Router übergibt die Parameter aus der URL an die Route-Komponente</p>
          <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
    // GreetingController erhält "greetingId" als Property
    &lt;Route path="/greeting/:greetingId" component={GreetingController} />
                                                        </code></pre>
          <p class="fragment">RouteComponentProps ist mit den erwarteten Parametern aus der URL generifiziert
            <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
  import { RouteComponentProps } from "react-router";
  
  // Die im Path definierten Parameter
  interface GreetingControllerParams { greetingId: string };
  
  // Als Type-Argument werden die Parameter angegeben
  interface GreetingControllerProps extends 
    RouteComponentProps&lt;GreetingControllerParams&gt {   }
  
  class GreetingController extends React.Component&lt;GreetingControllerProps> {
    render() {
      const params = this.props.match;
  
      const greetingId = params.greetingId; // ok, kein Compile-Fehler
      const userId = params.userId; // Fehler: userId nicht bekannt
    }
  }
    </code></pre>
        </section>
  
        <section id="t-hooks">
            <h1>React Hooks API</h1>
            <p><em>Mit der React Hooks API lassen sich State und Lifecycle-Methoden auch in Funktionen verwenden</em></p>
            <ul class="fragment">
            <li>
                <a href="https://github.com/nilshartmann/react-hook-and-suspense" target="_blank">Eine Beispiel Anwendung</a>
              </li>
              <li>
                  <a href="https://www.youtube.com/watch?v=u1oRaO-RtCI" target="_blank">Einführungstalk zu Hooks auf YouTube</a>
                </li>
                </ul>
        </section>

      <section id="t-typescript">
        <h2>React mit TypeScript entwickeln</h2>
        <p>
          <a href="code/schritte/5-typescript/public/index.html" target="_blank">Ziel-Anwendung</a>
        </p>
        <h3>Themen</h3>
        <ul>
          <li>
            <a href="#/t-typescript-grundlagen">TypeScript Grundlagen</a>
          </li>
          <li>
            <a href="#/t-typescript-react">React-Anwendungen mit TypeScript entwickeln</a>
          </li>
        </ul>
      </section>

      <section id="t-typescript-grundlagen">
        <h2>Hintergrund: TypeScript</h2>
        <p>
          <em>TypeScript is a superset of JavaScript that compiles to plain JavaScript </em>(
          <a href="http://www.typescriptlang.org/" target="_blank">http://www.typescriptlang.org/</a>)</p>
        <ul>
          <li>Erweitert JavaScript um ein Typen System</li>
          <li>Jeder gültige JavaScript Code ist auch gültiger TypeScript Code</li>
          <li>Mittels des TypeScript Compilers wird aus TS Code JavaScript Code</li>
        </ul>
      </section>

      <section>
        <h3>TypeScript Grundlagen</h3>
        <p>Typ-Angaben werden hinter einen Bezeichner geschrieben</p>
        <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
// Variablen können Typ-Informationen bekommen
let foo: string;
foo = 'yo';
// Error: number: This type is incompatible with string
foo = 10;
               </code></pre>
        <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
// Funktionen
function sayIt(what: string): string {
  return `Saying: ${what}`;
}

sayIt('Klaus'); // ok
sayIt(10); // error
</code></pre>


        <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
// Arrow Funktionen
const sayIt = (what: string): string => `Saying: ${what}`;

sayIt('Moin');
sayIt(123); // Error: Argument of type '123' is not assignable
            // to parameter of type 'string'.
</code></pre>
      </section>

      <section>
        <h2>Eingebaute Typen</h2>
        <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
// string
let city: string = 'Hamburg';

// boolean
let isDone: boolean = false;

// number
let theAnswer: number = 42;

// array (note the [])
let cities: string[] = ['Hamburg', 'Barcelona'];
// alternative:
let languages: Array&lt;string> = ['JavaScript', 'TypeScript'];

// any
let theUnknown: any = 'Who cares';
theUnknown = 666; // ok
theUnknown = true; // ok
let a: number = theUnknown; // ok

// void
function log(s: string): void { /* ... */ }
            </code></pre>

      </section>
      <section>
        <h2>Typen können abgeleitet (inferred) werden</h2>
        <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
let city = 'Hamburg'; // city ist ein String

city = 42;
// Fehler: [ts] Type '42' is not assignable to type 'string'.
</code></pre>
        <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
// Explizite Angabe eines Types (parameter)
// und abgeleiteter Typ (Return Type der Funktion)

function sayIt(what: string) {
  return `Saying: ${what}`;
}

const said: string = sayIt('Hello TypeScript'); // ok
const saidItWrong: number = sayIt('Hello TypeScript'); // error!


</code></pre>
      </section>
     
      <section>
        <h2>Type Check ausschalten</h2>
        <p>Mit
          <code>@ts-ignore</code> (als Kommentar) kann wird die Überprüfung der nächsten Zeile ausgeschaltet:</p>
        <pre><code class="typescript line-numbers" contenteditable data-trim>
let city:string = "Hamburg";

city = 20259; // error: [ts] Type '20259' is not assignable to type 'string'.

// @ts-ignore
city = 20259; // ok                
</code></pre>
        <p class="fragment">Nützlich in corner cases, die nur schwer mit TypeScript abbildbar sind oder bei Migration</p>
      </section>
      <section>
        <h2>null und undefined</h2>
        <div class="fragment">
          <p>
            <code>null</code> muss explizit zugelassen werden
            <em>(strictNullChecks</em>):</p>
          <pre><code class="typescript line-numbers" contenteditable data-trim>
let city:string = null; //Type 'null' is not assignable to type 'string'.

let optionalCity:string|null = null; // OK
            </code></pre>
        </div>
        <div class="fragment">
          <p>Optionale Parameter können mit ? gekennzeichnet werden (erlauben dann auch
            <code>undefined</code>)</p>
          <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
function greet(name: string, greeting?: string) {
  console.log(`${greeting || 'Hello'}, {name}`);
}

greet('Susi', 'Moin')// Moin, Susi

// 2. Parameter ist optional:
greet('Klaus'); // Hello, Klaus

greet('Peter', null); // Argument of type 'null' is not assignable
                      // to parameter of type 'string | undefined'.
            </code></pre>
        </div>
      </section>


      <section>
        <h2>Klassen</h2>
        <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
class Sayer {
  what: string; // Typ-Angabe für Felder ist erforderlich

  constructor(what: string) { // Typ-Angabe für Parameter ist erforderlich
    this.what = what;
  }

  // Angabe des Return-Types optional
  sayIt(): string {
    return `Saying: ${this.what}`;
  }
}

</code></pre>
      </section>

      <section>
        <h2>Klassen (Sichtbarkeiten)</h2>
        <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
class Sayer {
  // Erlaubte Sichtbarkeiten: private | protected | public
  private what: string; 

  constructor(what: string) { 
    this.what = what;
  }

  sayIt(): string {
    return `Saying: ${this.what}`;
  }
}

const sayer = new Sayer("Susi");
sayer.what = ""; // ERROR: Property 'greeting' is private

</code></pre>
      </section>
      <section>
        <h2>Klassen (Parameter Properties)</h2>
        <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
class Sayer {
  // identisch zu vorherigem Beispiel
  constructor(private what: string) {
  }

  sayIt(): string {
    return `Saying: ${this.what}`;
  }
}
</code></pre>
      </section>
      <section>
        <h2>Klassen (readonly Felder)</h2>
        <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
class Sayer {

  readonly what: string; 

  // Alternativ:
  constructor(readonly public what: string) {
  }

  setWhat(newWhat: string) {
    this.what = newWhat; // ERR Cannot assign to 'what' 
                         // because it is a read-only property.
  }
}
</code></pre>
      </section>
      <section>
        <h2>Eigene Typen</h2>
        <p>Mit
          <code>interface</code> können eigene Typen defniert werden:</p>

        <pre><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
// Komplexer Typ
interface Person {
	name: string; // Pflicht
	livesIn?: string; // Optional
}

const susi: Person = { // OK
	name: 'Klaus',
	livesIn: 'Hamburg'
};
const klaus: Person = { // OK (livesIn ist optional)
	name: 'Klaus'
}

const helmut: Person = {} // Error: Property 'name' is missing

const lukas: Person = {
	name: 'Lukas',
	profession: 'Lokführer'
} // Error: 'profession' does not exist in type 'Person'.
               </code></pre>

      </section>

      <section>
        <h2>Typ Kompatibilität</h2>
        <em>Im Gegensatz zu Java/C# ("nominal typing") sind bei TypeScript zwei Typen kompatibel, sofern sie
          <b>dieselbe Struktur</b> haben ("structural typing")</em>
        <pre><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
interface Book {
	title: string
}

interface Movie {
	title: string
}

const book:Book = { title: "Das Kapital" };
const movie:Movie = book; // OK, obwohl Book !== Movie
               </code></pre>
      </section>
      <section>
        <h2>Generics</h2>
        <p>Generische Typen verwenden</p>
        <pre><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
interface Person { name: string };
interface Movie { title: string };

let persons:Array&lt;Person&gt; = [];
let movies:Array&lt;Movie&gt; = [];

persons.push({name: 'Klaus'});
movies.push({title: 'Batman'});

persons.push({title: 'Casablanca'}) // error ('title' not in Person)

persons = movies; // error

      </code></pre>
      </section>
   
      <section id="t-typescript-react">
        <h2>React Anwendungen mit TypeScript</h2>
        <em>State und Properties von Komponenten werden mit Typen beschrieben</em>
      </section>
      
      <section>
        <h2>Getypte React Komponenten</h2>
        <p>
          <code>React.Component</code> ist eine generische Klasse, die einen Typ für Properties und State erwartet</p>
        <pre class="fragment"><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
interface Greeting = {name: string; greeting: string};

interface GreetingDetailProps {
    greeting?: Greeting;
    onSave: (newGreeting: NewGreeting) => void;
}

interface GreetingDetailState {
    name: string;
    greeting: string;
}
            </code></pre>

        <pre class="fragment"><code data-trim contenteditable class="line-numbers typescript" data-leftpad>

class GreetingDetail
  extends React.Component&lt;GreetingDetailProps, GreetingDetailState> {
  // ...
}
            </code></pre>
      </section>
      <section>
        <h3>Typsicherheit in React Komponenten</h3>
        <p>Properties und State sind typsicher</p>
        <pre class="fragment"><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
constructor(props: Props) {
    super(props);

    this.state = { name: '', greeting: ''} // OK

    // ERROR: Object literal may only specify known properties,
    // and 'aha' does not exist in type 'Readonly&lt;State>'
    this.state = {name: '', greeting: '', aha: 10};

    // ERROR: Cannot assign to 'greeting' because
    // it is a constant or a read-only property.
    this.state.greeting = 'no way';
}

render() {
  // ERROR: Property 'nothere' does not exist on type...
  return &lt;div>{this.props.nothere}&lt;/iv>;
}
               </code></pre>
      </section>
      <section>
        <h2>React Events in TypeScript</h2>
        <span class="fragment">
          <pre><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
class GreetingDetail extends React.Component&lt;Props, State> {
  // . . .
  updateModel(event: React.SyntheticEvent&lt;HTMLInputElement>) {
    // 'currentTarget' anstatt 'target' verwenden:
    const { name, value } = event.currentTarget;
    // . . .

    // Compile error! 
    this.setState({[name]}: value);

    // @ts-ignore 
    this.setState({[name]}: value);
  }
}

        </code></pre>
          <p>
            <a href="https://github.com/DefinitelyTyped/DefinitelyTyped/issues/11508#issuecomment-256045682" target="_blank">
              <code>target</code> vs
              <code>currentTarget</code>
            </a>
          </p>
        </span>

      </section>
      <section>
        <h2>Functional Components</h2>
        <pre class="fragment"><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
type GreetingMasterProps = {
    greetings: Greeting[]
    onAdd: () => void
};
        </code></pre>
        <pre class="fragment"><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
const GreetingMaster = (props: GreetingMasterProps) => {
    const {greetings, onAdd} = props;
    // . . .
}

        </code></pre>
        <pre class="fragment"><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
// or
const GreetingMaster = ({greetings, onAdd}: GreetingMasterProps) => {
    // . . .
}

        </code></pre>
        <pre class="fragment"><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
// or
const GreetingMaster: React.FunctionComponent&lt;GreetingMasterProps> = props => {
    const {greetings, onAdd} = props;
    // . . .
}
        </code></pre>
      </section>
      <section>
        <h2>Übung: Eine Komponente auf TypeScript umstellen</h2>
        <h3>
          <em>Stelle die GreetingDetail Komponente auf TypeScript um</em>
        </h3>
        <div style="font-size: 80%">
          <p>
            <b>Hinweis: </b> Bitte arbeite dazu in dem neuen Workspace
            <code>code/workspace-typescript</code>:</p>
          <ul>
            <li>Dieses Verzeichnis enthält die Anwendung aus unserem letzten Schritt, aber in TypeScript implementiert</li>
            <li>Lediglich das
              <code>GreetingDetail</code> ist noch in JavaScript implementiert</li>
            <li>Du kannst den Webpack Server in diesem Verzeichnis ebenfalls mit
              <code>npm start</code> starten</li>
            <li>Denk dran, deinen laufenden Webpack Server vorher zu beenden</li>
          </ul>
        </div>
      </section>
      <section>
        <h2>Schritte</h2>
        <ol style="font-size:80%">
          <li>Definiere einen Typen für die Properties und den State und passe die
            <code>GreetingDetail</code>-Klasse an</li>
          <li>Füge der Komponente das
            <code>input</code>-Property hinzu (Type:
            <code>HTMLInputElement</code>)</li>
          <li>Experimentiere (optional):
            <ul>
              <li>Was passiert, wenn Du im
                <code>GreetingDetail</code> auf ein nicht bekanntes Property zugreifst?</li>
              <li>Was passiert, wenn Du im
                <code>GreetingDetail</code> den State mit
                <code>this.state = { . . .}</code> neu setzt?
              </li>
              <li>Was passiert, wenn Du beim Aufrufen des
                <code>GreetingDetail</code> (
                <code>GreetingController</code>) ein zusätzliches Property übergibst?</li>
            </ul>
          </li>
        </ol>
      </section>
    
      <section>
        <h2>Geschafft ;-)</h2>
        <h3>Vielen Dank für Eure Teilnahme!</h3>
        <p>Kontakt: <a href="mailto:nils@nilshartmann.net">nils@nilshartmann.net</a> | <a href="https://xing.to/nilshartmann" target="_blank">Xing</a> | <a href="https://twitter.com/nilshartmann" target="_blank">@nilshartmann</a></p>
      </section>


    </div>

  </div>

  <script src="reveal.js/lib/js/head.min.js"></script>
  <script src="reveal.js/js/reveal.js"></script>
  <script src="reveal.js/lib/jquery-2.2.4.js"></script>

  <script>
     const isLocalServer = window.location.hostname.indexOf('localhost') !== -1 || 
                    window.location.hostname.indexOf('127.0.0.1') !== -1;

    Reveal.addEventListener('ready', function (event) {
      if (isLocalServer) {
        // only applies to presentation version
        Reveal.configure({ controls: false });
      } else {
        // only applies to public version
        //            $('.fragment').removeClass('fragment');
      }
      // applies to all versions
      // $('code').removeClass('line-numbers');
      //        $('.fragment').removeClass('fragment');
    });
  </script>


  <script>
    // Full list of configuration options available at:
    // https://github.com/hakimel/reveal.js#configuration
    Reveal.initialize({
      controls: true,
      progress: true,
      history: true,
      center: true,

      width: '100%',
      height: '100%',

      transition: 'slide', // none/fade/slide/convex/concave/zoom

      // Optional reveal.js plugins
      dependencies: [
        {
          src: 'reveal.js/lib/js/classList.js', condition: function () {
            return !document.body.classList;
          }
        },
        {
          src: 'reveal.js/plugin/markdown/marked.js', condition: function () {
            return !!document.querySelector('[data-markdown]');
          }
        },
        {
          src: 'reveal.js/plugin/markdown/markdown.js', condition: function () {
            return !!document.querySelector('[data-markdown]');
          }
        },
        {
          src: 'reveal.js/plugin/highlight/highlight.js', async: true, condition: function () {
            return !!document.querySelector('pre code');
          }, callback: function () {
            hljs.initHighlightingOnLoad();
          }
        },
        { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true },
        { src: 'reveal.js/plugin/notes/notes.js', async: true },
        { src: 'reveal.js/lib/js/line-numbers.js' }
      ]
    });

  </script>

</body>

</html>
# Testen

- Basis: TypeScript-Variante **ohne Router**
- PostEditor (Events, Callbacks, Find by Role)
- App-Komponente umbauen, und eigentlich fetch-Code in backend.js auslagern
- Dann kann im ersten Schritt backend.js gemockt werden (immer noch asynchron (?)) als Beispiel für Mocking und asynchronität
- Im zweiten Schritt fetch strategien:

  - window.fetch
  - mdw
  - jest-fetch-mock

# Patterns (HOC, Render Properties, Custom Hooks)

- DataLoader Komponente ausreichend (eigene App, die einfach nur Daten lädt, eventuell in zwei Komponenten, um Wiederverwendbarkeit zu demonstrieren)
- **Eine** App mit unterschiedlichen Views für die drei Beispiele

# Router

_Die folgenden Beispiele verwenden alle den Router, dh hier **muss** eine kurze Router Einführung folgen_

# Redux

- State-Talk Beispiel verwenden
- Context-Variante davon nicht sinnvoll

# Memoization

# graphql

GraphQL, Stand aus blog-example, d.h. mit einloggen, aber ohne Sidebar etc.

Focus: GraphQL (kein Statemanagement)
